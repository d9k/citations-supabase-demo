--
-- PostgreSQL database dump
--

-- Dumped from database version 15.1 (Ubuntu 15.1-1.pgdg20.04+1)
-- Dumped by pg_dump version 15.4 (Ubuntu 15.4-1.pgdg20.04+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: supabase_migrations; Owner: postgres
--

INSERT INTO "supabase_migrations"."schema_migrations" ("version", "statements", "name") VALUES
	('20231129030618', '{"SET statement_timeout = 0","SET lock_timeout = 0","SET idle_in_transaction_session_timeout = 0","SET client_encoding = ''UTF8''","SET standard_conforming_strings = on","SELECT pg_catalog.set_config(''search_path'', '''', false)","SET check_function_bodies = false","SET xmloption = content","SET client_min_messages = warning","SET row_security = off","CREATE EXTENSION IF NOT EXISTS \"pgsodium\" WITH SCHEMA \"pgsodium\"","CREATE EXTENSION IF NOT EXISTS \"pg_graphql\" WITH SCHEMA \"graphql\"","CREATE EXTENSION IF NOT EXISTS \"pg_stat_statements\" WITH SCHEMA \"extensions\"","CREATE EXTENSION IF NOT EXISTS \"pgcrypto\" WITH SCHEMA \"extensions\"","CREATE EXTENSION IF NOT EXISTS \"pgjwt\" WITH SCHEMA \"extensions\"","CREATE EXTENSION IF NOT EXISTS \"supabase_vault\" WITH SCHEMA \"vault\"","CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\" WITH SCHEMA \"extensions\"","SET default_tablespace = ''''","SET default_table_access_method = \"heap\"","CREATE TABLE IF NOT EXISTS \"public\".\"authors\" (
    \"id\" bigint NOT NULL,
    \"lastname_name_patronymic\" \"text\" NOT NULL,
    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,
    \"birth_year\" bigint,
    \"death_year\" bigint,
    \"approximate_years\" boolean DEFAULT false NOT NULL,
    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL
)","ALTER TABLE \"public\".\"authors\" OWNER TO \"postgres\"","ALTER TABLE \"public\".\"authors\" ALTER COLUMN \"id\" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME \"public\".\"author_id_seq\"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
)","CREATE TABLE IF NOT EXISTS \"public\".\"citations\" (
    \"id\" bigint NOT NULL,
    \"english_text\" \"text\",
    \"author_id\" bigint NOT NULL,
    \"year\" bigint,
    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,
    \"updated_at\" timestamp without time zone DEFAULT \"now\"() NOT NULL,
    \"original_language_text\" \"text\"
)","ALTER TABLE \"public\".\"citations\" OWNER TO \"postgres\"","ALTER TABLE \"public\".\"citations\" ALTER COLUMN \"id\" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME \"public\".\"citations_id_seq\"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
)","CREATE TABLE IF NOT EXISTS \"public\".\"country\" (
    \"id\" bigint NOT NULL,
    \"name\" \"text\",
    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,
    \"updated_at\" timestamp with time zone DEFAULT \"now\"(),
    \"found_year\" bigint,
    \"next_rename_year\" bigint
)","ALTER TABLE \"public\".\"country\" OWNER TO \"postgres\"","ALTER TABLE \"public\".\"country\" ALTER COLUMN \"id\" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME \"public\".\"country_id_seq\"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
)","CREATE TABLE IF NOT EXISTS \"public\".\"place\" (
    \"id\" bigint NOT NULL,
    \"name\" \"text\" DEFAULT ''in''::\"text\" NOT NULL,
    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,
    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL
)","ALTER TABLE \"public\".\"place\" OWNER TO \"postgres\"","ALTER TABLE \"public\".\"place\" ALTER COLUMN \"id\" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME \"public\".\"place_id_seq\"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
)","CREATE TABLE IF NOT EXISTS \"public\".\"province\" (
    \"id\" bigint NOT NULL,
    \"name\" \"text\" NOT NULL,
    \"country_id\" bigint NOT NULL,
    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,
    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL
)","ALTER TABLE \"public\".\"province\" OWNER TO \"postgres\"","ALTER TABLE \"public\".\"province\" ALTER COLUMN \"id\" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME \"public\".\"province_id_seq\"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
)","CREATE TABLE IF NOT EXISTS \"public\".\"town\" (
    \"id\" bigint NOT NULL,
    \"name\" \"text\" NOT NULL,
    \"province_id\" bigint NOT NULL,
    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,
    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL
)","ALTER TABLE \"public\".\"town\" OWNER TO \"postgres\"","ALTER TABLE \"public\".\"town\" ALTER COLUMN \"id\" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME \"public\".\"town_id_seq\"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
)","ALTER TABLE ONLY \"public\".\"authors\"
    ADD CONSTRAINT \"author_pkey\" PRIMARY KEY (\"id\")","ALTER TABLE ONLY \"public\".\"citations\"
    ADD CONSTRAINT \"citations_pkey\" PRIMARY KEY (\"id\")","ALTER TABLE ONLY \"public\".\"country\"
    ADD CONSTRAINT \"country_pkey\" PRIMARY KEY (\"id\")","ALTER TABLE ONLY \"public\".\"place\"
    ADD CONSTRAINT \"place_pkey\" PRIMARY KEY (\"id\")","ALTER TABLE ONLY \"public\".\"province\"
    ADD CONSTRAINT \"province_pkey\" PRIMARY KEY (\"id\")","ALTER TABLE ONLY \"public\".\"town\"
    ADD CONSTRAINT \"town_pkey\" PRIMARY KEY (\"id\")","ALTER TABLE ONLY \"public\".\"citations\"
    ADD CONSTRAINT \"citations_author_id_fkey\" FOREIGN KEY (\"author_id\") REFERENCES \"public\".\"authors\"(\"id\") ON UPDATE CASCADE ON DELETE RESTRICT","ALTER TABLE ONLY \"public\".\"province\"
    ADD CONSTRAINT \"province_country_id_fkey\" FOREIGN KEY (\"country_id\") REFERENCES \"public\".\"country\"(\"id\") ON UPDATE CASCADE ON DELETE RESTRICT","ALTER TABLE ONLY \"public\".\"town\"
    ADD CONSTRAINT \"town_province_id_fkey\" FOREIGN KEY (\"province_id\") REFERENCES \"public\".\"province\"(\"id\") ON UPDATE CASCADE ON DELETE RESTRICT","REVOKE USAGE ON SCHEMA \"public\" FROM PUBLIC","GRANT USAGE ON SCHEMA \"public\" TO \"postgres\"","GRANT USAGE ON SCHEMA \"public\" TO \"anon\"","GRANT USAGE ON SCHEMA \"public\" TO \"authenticated\"","GRANT USAGE ON SCHEMA \"public\" TO \"service_role\"","GRANT ALL ON TABLE \"public\".\"authors\" TO \"anon\"","GRANT ALL ON TABLE \"public\".\"authors\" TO \"authenticated\"","GRANT ALL ON TABLE \"public\".\"authors\" TO \"service_role\"","GRANT ALL ON SEQUENCE \"public\".\"author_id_seq\" TO \"anon\"","GRANT ALL ON SEQUENCE \"public\".\"author_id_seq\" TO \"authenticated\"","GRANT ALL ON SEQUENCE \"public\".\"author_id_seq\" TO \"service_role\"","GRANT ALL ON TABLE \"public\".\"citations\" TO \"anon\"","GRANT ALL ON TABLE \"public\".\"citations\" TO \"authenticated\"","GRANT ALL ON TABLE \"public\".\"citations\" TO \"service_role\"","GRANT ALL ON SEQUENCE \"public\".\"citations_id_seq\" TO \"anon\"","GRANT ALL ON SEQUENCE \"public\".\"citations_id_seq\" TO \"authenticated\"","GRANT ALL ON SEQUENCE \"public\".\"citations_id_seq\" TO \"service_role\"","GRANT ALL ON TABLE \"public\".\"country\" TO \"anon\"","GRANT ALL ON TABLE \"public\".\"country\" TO \"authenticated\"","GRANT ALL ON TABLE \"public\".\"country\" TO \"service_role\"","GRANT ALL ON SEQUENCE \"public\".\"country_id_seq\" TO \"anon\"","GRANT ALL ON SEQUENCE \"public\".\"country_id_seq\" TO \"authenticated\"","GRANT ALL ON SEQUENCE \"public\".\"country_id_seq\" TO \"service_role\"","GRANT ALL ON TABLE \"public\".\"place\" TO \"anon\"","GRANT ALL ON TABLE \"public\".\"place\" TO \"authenticated\"","GRANT ALL ON TABLE \"public\".\"place\" TO \"service_role\"","GRANT ALL ON SEQUENCE \"public\".\"place_id_seq\" TO \"anon\"","GRANT ALL ON SEQUENCE \"public\".\"place_id_seq\" TO \"authenticated\"","GRANT ALL ON SEQUENCE \"public\".\"place_id_seq\" TO \"service_role\"","GRANT ALL ON TABLE \"public\".\"province\" TO \"anon\"","GRANT ALL ON TABLE \"public\".\"province\" TO \"authenticated\"","GRANT ALL ON TABLE \"public\".\"province\" TO \"service_role\"","GRANT ALL ON SEQUENCE \"public\".\"province_id_seq\" TO \"anon\"","GRANT ALL ON SEQUENCE \"public\".\"province_id_seq\" TO \"authenticated\"","GRANT ALL ON SEQUENCE \"public\".\"province_id_seq\" TO \"service_role\"","GRANT ALL ON TABLE \"public\".\"town\" TO \"anon\"","GRANT ALL ON TABLE \"public\".\"town\" TO \"authenticated\"","GRANT ALL ON TABLE \"public\".\"town\" TO \"service_role\"","GRANT ALL ON SEQUENCE \"public\".\"town_id_seq\" TO \"anon\"","GRANT ALL ON SEQUENCE \"public\".\"town_id_seq\" TO \"authenticated\"","GRANT ALL ON SEQUENCE \"public\".\"town_id_seq\" TO \"service_role\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON SEQUENCES  TO \"postgres\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON SEQUENCES  TO \"anon\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON SEQUENCES  TO \"authenticated\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON SEQUENCES  TO \"service_role\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON FUNCTIONS  TO \"postgres\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON FUNCTIONS  TO \"anon\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON FUNCTIONS  TO \"authenticated\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON FUNCTIONS  TO \"service_role\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON TABLES  TO \"postgres\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON TABLES  TO \"anon\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON TABLES  TO \"authenticated\"","ALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON TABLES  TO \"service_role\"","RESET ALL"}', 'remote_schema'),
	('20231129093821', '{"alter table \"public\".\"province\" drop constraint \"province_country_id_fkey\"","alter table \"public\".\"town\" drop constraint \"town_province_id_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_author_id_fkey\"","alter table \"public\".\"province\" drop constraint \"province_pkey\"","drop index if exists \"public\".\"province_pkey\"","drop table \"public\".\"province\"","create table \"public\".\"event\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"start_year\" bigint not null,
    \"start_month\" smallint not null,
    \"end_year\" bigint,
    \"end_month\" smallint,
    \"place_id\" bigint
)","alter table \"public\".\"authors\" add column \"birth_town\" bigint","alter table \"public\".\"citations\" add column \"event_id\" bigint","alter table \"public\".\"citations\" add column \"place_id\" bigint","alter table \"public\".\"place\" add column \"town_id\" bigint not null","alter table \"public\".\"town\" drop column \"province_id\"","alter table \"public\".\"town\" add column \"country_id\" bigint not null","CREATE UNIQUE INDEX event_pkey ON public.event USING btree (id)","alter table \"public\".\"event\" add constraint \"event_pkey\" PRIMARY KEY using index \"event_pkey\"","alter table \"public\".\"authors\" add constraint \"authors_birth_town_fkey\" FOREIGN KEY (birth_town) REFERENCES town(id) ON UPDATE CASCADE not valid","alter table \"public\".\"authors\" validate constraint \"authors_birth_town_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_event_id_fkey\" FOREIGN KEY (event_id) REFERENCES event(id) ON UPDATE CASCADE not valid","alter table \"public\".\"citations\" validate constraint \"citations_event_id_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_place_id_fkey\" FOREIGN KEY (place_id) REFERENCES place(id) not valid","alter table \"public\".\"citations\" validate constraint \"citations_place_id_fkey\"","alter table \"public\".\"event\" add constraint \"event_place_id_fkey\" FOREIGN KEY (place_id) REFERENCES place(id) ON UPDATE CASCADE not valid","alter table \"public\".\"event\" validate constraint \"event_place_id_fkey\"","alter table \"public\".\"place\" add constraint \"place_town_id_fkey\" FOREIGN KEY (town_id) REFERENCES town(id) ON UPDATE CASCADE not valid","alter table \"public\".\"place\" validate constraint \"place_town_id_fkey\"","alter table \"public\".\"town\" add constraint \"town_country_id_fkey\" FOREIGN KEY (country_id) REFERENCES country(id) ON UPDATE CASCADE not valid","alter table \"public\".\"town\" validate constraint \"town_country_id_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_author_id_fkey\" FOREIGN KEY (author_id) REFERENCES authors(id) ON UPDATE CASCADE not valid","alter table \"public\".\"citations\" validate constraint \"citations_author_id_fkey\""}', 'remote_schema'),
	('20231129114012', '{"create table \"public\".\"profiles\" (
    \"id\" uuid not null,
    \"updated_at\" timestamp with time zone,
    \"username\" text,
    \"full_name\" text,
    \"avatar_url\" text,
    \"website\" text
)","alter table \"public\".\"profiles\" enable row level security","CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id)","CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username)","alter table \"public\".\"profiles\" add constraint \"profiles_pkey\" PRIMARY KEY using index \"profiles_pkey\"","alter table \"public\".\"profiles\" add constraint \"profiles_id_fkey\" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid","alter table \"public\".\"profiles\" validate constraint \"profiles_id_fkey\"","alter table \"public\".\"profiles\" add constraint \"profiles_username_key\" UNIQUE using index \"profiles_username_key\"","alter table \"public\".\"profiles\" add constraint \"username_length\" CHECK ((char_length(username) >= 3)) not valid","alter table \"public\".\"profiles\" validate constraint \"username_length\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>''full_name'', new.raw_user_meta_data->>''avatar_url'');
  return new;
end;
$function$","create policy \"Public profiles are viewable by everyone.\"
on \"public\".\"profiles\"
as permissive
for select
to public
using (true)","create policy \"Users can insert their own profile.\"
on \"public\".\"profiles\"
as permissive
for insert
to public
with check ((auth.uid() = id))","create policy \"Users can update own profile.\"
on \"public\".\"profiles\"
as permissive
for update
to public
using ((auth.uid() = id))"}', 'user_management_starter'),
	('20231207142347', '{"alter table \"public\".\"town\" drop constraint \"town_country_id_fkey\"","alter table \"public\".\"country\" drop constraint \"country_pkey\"","drop index if exists \"public\".\"country_pkey\"","drop table \"public\".\"country\"","create table \"public\".\"countries\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone default now(),
    \"found_year\" bigint,
    \"next_rename_year\" bigint
)","CREATE UNIQUE INDEX country_pkey ON public.countries USING btree (id)","alter table \"public\".\"countries\" add constraint \"country_pkey\" PRIMARY KEY using index \"country_pkey\"","alter table \"public\".\"town\" add constraint \"town_country_id_fkey\" FOREIGN KEY (country_id) REFERENCES countries(id) ON UPDATE CASCADE not valid","alter table \"public\".\"town\" validate constraint \"town_country_id_fkey\""}', 'rename_countries'),
	('20231209022533', '{"CREATE TRIGGER on_auth_user_new AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_auth_user_new()","drop policy \"Users can insert their own profile.\" on \"public\".\"profiles\"","drop policy \"Users can update own profile.\" on \"public\".\"profiles\"","alter table \"public\".\"profiles\" drop constraint \"profiles_id_fkey\"","drop function if exists \"public\".\"handle_new_user\"()","alter table \"public\".\"countries\" enable row level security","alter table \"public\".\"profiles\" add column \"auth_user_id\" uuid not null","alter table \"public\".\"profiles\" alter column \"id\" add generated by default as identity","alter table \"public\".\"profiles\" alter column \"id\" set data type bigint using \"id\"::bigint","alter table \"public\".\"profiles\" add constraint \"profiles_id_fkey\" FOREIGN KEY (auth_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid","alter table \"public\".\"profiles\" validate constraint \"profiles_id_fkey\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.delete_claim(uid uuid, claim text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''error: access denied'';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data - claim where id = uid;
        return ''OK'';
      END IF;
    END;
$function$","CREATE OR REPLACE FUNCTION public.get_claim(uid uuid, claim text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    DECLARE retval jsonb;
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''{\"error\":\"access denied\"}''::jsonb;
      ELSE
        select coalesce(raw_app_meta_data->claim, null) from auth.users into retval where id = uid::uuid;
        return retval;
      END IF;
    END;
$function$","CREATE OR REPLACE FUNCTION public.get_claims(uid uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    DECLARE retval jsonb;
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''{\"error\":\"access denied\"}''::jsonb;
      ELSE
        select raw_app_meta_data from auth.users into retval where id = uid::uuid;
        return retval;
      END IF;
    END;
$function$","CREATE OR REPLACE FUNCTION public.get_my_claim(claim text)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting(''request.jwt.claims'', true), '''')::jsonb -> ''app_metadata'' -> claim, null)
$function$","CREATE OR REPLACE FUNCTION public.get_my_claims()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting(''request.jwt.claims'', true), '''')::jsonb -> ''app_metadata'', ''{}''::jsonb)::jsonb
$function$","CREATE OR REPLACE FUNCTION public.handle_auth_user_new()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profiles (auth_user_id, full_name, avatar_url)
	  VALUES (
		  NEW.id,
		  NEW.raw_user_meta_data->>''full_name'',
		  NEW.raw_user_meta_data->>''avatar_url''
	  );
  RETURN NEW;
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_public_profile_new()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$

BEGIN

/**
 * see `set claim` at
 * https://github.com/supabase-community/supabase-custom-claims/blob/main/install.sql
 **/
  UPDATE auth.users
  SET
	  raw_app_meta_data = COALESCE(
		  raw_app_meta_data || JSON_BUILD_OBJECT(''profile_id'', NEW.id)::jsonb,
		  JSON_BUILD_OBJECT(''profile_id'', NEW.id)::jsonb
	  )
  WHERE id = NEW.auth_user_id;

  RETURN NEW;
END;
$function$","CREATE OR REPLACE FUNCTION public.is_claims_admin()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
  BEGIN
    IF session_user = ''authenticator'' THEN
      --------------------------------------------
      -- To disallow any authenticated app users
      -- from editing claims, delete the following
      -- block of code and replace it with:
      -- RETURN FALSE;
      --------------------------------------------
      IF extract(epoch from now()) > coalesce((current_setting(''request.jwt.claims'', true)::jsonb)->>''exp'', ''0'')::numeric THEN
        return false; -- jwt expired
      END IF;
      If current_setting(''request.jwt.claims'', true)::jsonb->>''role'' = ''service_role'' THEN
        RETURN true; -- service role users have admin rights
      END IF;
      IF coalesce((current_setting(''request.jwt.claims'', true)::jsonb)->''app_metadata''->''claims_admin'', ''false'')::bool THEN
        return true; -- user has claims_admin set to true
      ELSE
        return false; -- user does NOT have claims_admin set to true
      END IF;
      --------------------------------------------
      -- End of block 
      --------------------------------------------
    ELSE -- not a user session, probably being called from a trigger or something
      return true;
    END IF;
  END;
$function$","CREATE OR REPLACE FUNCTION public.set_claim(uid uuid, claim text, value jsonb)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''error: access denied'';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data || 
            json_build_object(claim, value)::jsonb where id = uid;
        return ''OK'';
      END IF;
    END;
$function$","create policy \"countries: authed can read\"
on \"public\".\"countries\"
as permissive
for select
to authenticated
using (true)","create policy \"Users can insert their own profile.\"
on \"public\".\"profiles\"
as permissive
for insert
to public
with check ((auth.uid() = auth_user_id))","create policy \"Users can update own profile.\"
on \"public\".\"profiles\"
as permissive
for update
to public
using ((auth.uid() = auth_user_id))","CREATE TRIGGER on_public_profiles_new AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION handle_public_profile_new()"}', 'profile_id'),
	('20231221015017', '{"drop policy \"countries: authed can read\" on \"public\".\"countries\"","alter table \"public\".\"profiles\" drop constraint \"profiles_pkey\"","drop index if exists \"public\".\"profiles_pkey\"","alter table \"public\".\"countries\" add column \"created_by\" bigint","alter table \"public\".\"countries\" add column \"updated_by\" bigint","alter table \"public\".\"countries\" alter column \"name\" set default ''''::text","alter table \"public\".\"countries\" alter column \"name\" set not null","CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id)","alter table \"public\".\"profiles\" add constraint \"profiles_pkey\" PRIMARY KEY using index \"profiles_pkey\"","alter table \"public\".\"countries\" add constraint \"countries_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"countries\" validate constraint \"countries_created_by_fkey\"","alter table \"public\".\"countries\" add constraint \"countries_name_check\" CHECK ((length(name) > 0)) not valid","alter table \"public\".\"countries\" validate constraint \"countries_name_check\"","alter table \"public\".\"countries\" add constraint \"countries_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"countries\" validate constraint \"countries_updated_by_fkey\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.handle_fill_created_by()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  NEW.created_by := get_my_claim(''profile_id'');
  RETURN NEW;
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_fill_updated()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  NEW.updated_by := get_my_claim(''profile_id'');
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$function$","create policy \"countries: authed can all\"
on \"public\".\"countries\"
as permissive
for all
to authenticated
using (true)
with check (true)","CREATE TRIGGER on_country_edit_fill_update BEFORE UPDATE ON public.countries FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_country_new_fill_created_by BEFORE INSERT ON public.countries FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()"}', 'countries_fill_created_updated'),
	('20231223035856', '{"drop policy \"Users can update own profile.\" on \"public\".\"profiles\"","create table \"public\".\"trusts\" (
    \"id\" bigint generated by default as identity not null,
    \"who\" bigint not null,
    \"trusts_who\" bigint not null
)","alter table \"public\".\"trusts\" enable row level security","CREATE UNIQUE INDEX countries_name_key ON public.countries USING btree (name)","CREATE UNIQUE INDEX trusts_pkey ON public.trusts USING btree (id)","alter table \"public\".\"trusts\" add constraint \"trusts_pkey\" PRIMARY KEY using index \"trusts_pkey\"","alter table \"public\".\"countries\" add constraint \"countries_name_key\" UNIQUE using index \"countries_name_key\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.rls_profiles_edit(record profiles)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RAISE LOG ''rls_profiles_edit: profile %'', record.id;
    RETURN auth.uid() = record.auth_user_id;
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_profiles_edit(records profiles[])
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    t profiles;
BEGIN
  FOREACH t IN ARRAY records LOOP
    RAISE LOG ''rls_profiles_edit: profiles %'', t.id;
    RETURN TRUE;
  END LOOP;
END;
$function$","CREATE OR REPLACE FUNCTION public.temporary_fn()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RAISE LOG ''This is an informational message'';
  RETURN TRUE;
END;
$function$","create or replace view \"public\".\"rls_edit_for_table\" as  SELECT ''profiles''::text AS table_name,
    profiles.id,
    rls_profiles_edit(profiles.*) AS editable
   FROM profiles","create policy \"Users can update own profile.\"
on \"public\".\"profiles\"
as permissive
for update
to public
using (rls_profiles_edit(profiles.*))"}', 'rls_profiles_edit'),
	('20231224133725', '{"drop policy \"countries: authed can all\" on \"public\".\"countries\"","alter table \"public\".\"trusts\" rename column \"trusts_who\" to \"trusts_whom\"","alter table \"public\".\"trusts\" add column \"end_at\" timestamp with time zone not null default (now() + ''1 day''::interval)","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.rls_check_edit_by_created_by(created_by bigint, allow_trust boolean DEFAULT true, claim_check character varying DEFAULT ''claim_edit_all_content''::character varying)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	profile_id int8;
BEGIN
  profile_id := get_my_claim(''profile_id'')::int;
	-- RAISE WARNING ''rls_check_by_created_by: created_by: %, profile_id: %'', created_by, profile_id;
	-- RETURN TRUE;
	RETURN get_my_claim(claim_check)::varchar::boolean
	    OR (profile_id = created_by)
	   	OR (
				allow_trust AND ((
					SELECT TRUE
					FROM trusts
					WHERE NOW() < trusts.end_at
					AND created_by = trusts.who
						AND profile_id = trusts.trusts_whom
				))
			);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_check_delete_by_created_by(created_by bigint, allow_trust boolean DEFAULT true, claim_check character varying DEFAULT ''claim_delete_all_content''::character varying)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
	RETURN rls_check_edit_by_created_by(created_by, allow_trust, claim_check);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_countries_delete(record countries)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_countries_edit(record countries)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","create or replace view \"public\".\"rls_edit_for_table\" as  SELECT ''profiles''::text AS table_name,
    profiles.id,
    rls_profiles_edit(profiles.*) AS editable,
    false AS deletable
   FROM profiles
UNION
 SELECT ''countries''::text AS table_name,
    countries.id,
    rls_countries_edit(countries.*) AS editable,
    rls_countries_delete(countries.*) AS deletable
   FROM countries","CREATE OR REPLACE FUNCTION public.set_claim(uid uuid, claim text, value jsonb)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''error: access denied'';
      ELSE
        update auth.users set raw_app_meta_data =
          raw_app_meta_data ||
            json_build_object(claim, value)::jsonb where id = uid;
        return ''OK'';
      END IF;
    END;
$function$","create policy \"RLS: countries: delete\"
on \"public\".\"countries\"
as permissive
for delete
to authenticated
using (rls_countries_edit(countries.*))","create policy \"RLS: countries: insert\"
on \"public\".\"countries\"
as permissive
for insert
to authenticated
with check (rls_countries_edit(countries.*))","create policy \"RLS: countries: select\"
on \"public\".\"countries\"
as permissive
for select
to public
using (true)","create policy \"RLS: countries: update\"
on \"public\".\"countries\"
as permissive
for update
to authenticated
with check (rls_countries_edit(countries.*))","create policy \"Enable read access for all users\"
on \"public\".\"trusts\"
as permissive
for select
to public
using (true)"}', 'rls_check_edit_by_created_by_for_countries'),
	('20231224200604', '{"drop policy \"RLS: countries: delete\" on \"public\".\"countries\"","alter table \"public\".\"event\" drop constraint \"event_place_id_fkey\"","alter table \"public\".\"place\" drop constraint \"place_town_id_fkey\"","alter table \"public\".\"town\" drop constraint \"town_country_id_fkey\"","alter table \"public\".\"authors\" drop constraint \"authors_birth_town_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_event_id_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_place_id_fkey\"","alter table \"public\".\"event\" drop constraint \"event_pkey\"","alter table \"public\".\"place\" drop constraint \"place_pkey\"","alter table \"public\".\"town\" drop constraint \"town_pkey\"","drop index if exists \"public\".\"event_pkey\"","drop index if exists \"public\".\"place_pkey\"","drop index if exists \"public\".\"town_pkey\"","drop table \"public\".\"event\"","drop table \"public\".\"place\"","drop table \"public\".\"town\"","create table \"public\".\"events\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"start_year\" bigint not null,
    \"start_month\" smallint not null,
    \"end_year\" bigint,
    \"end_month\" smallint,
    \"place_id\" bigint,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","create table \"public\".\"places\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null default ''in''::text,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"town_id\" bigint not null,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","create table \"public\".\"towns\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"country_id\" bigint not null,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"authors\" add column \"created_by\" bigint","alter table \"public\".\"authors\" add column \"updated_by\" bigint","alter table \"public\".\"citations\" add column \"created_by\" bigint","alter table \"public\".\"citations\" add column \"updated_by\" bigint","alter table \"public\".\"profiles\" add column \"created_at\" timestamp with time zone default now()","CREATE UNIQUE INDEX event_pkey ON public.events USING btree (id)","CREATE UNIQUE INDEX place_pkey ON public.places USING btree (id)","CREATE UNIQUE INDEX town_pkey ON public.towns USING btree (id)","alter table \"public\".\"events\" add constraint \"event_pkey\" PRIMARY KEY using index \"event_pkey\"","alter table \"public\".\"places\" add constraint \"place_pkey\" PRIMARY KEY using index \"place_pkey\"","alter table \"public\".\"towns\" add constraint \"town_pkey\" PRIMARY KEY using index \"town_pkey\"","alter table \"public\".\"authors\" add constraint \"authors_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"authors\" validate constraint \"authors_created_by_fkey\"","alter table \"public\".\"authors\" add constraint \"authors_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"authors\" validate constraint \"authors_updated_by_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"citations\" validate constraint \"citations_created_by_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"citations\" validate constraint \"citations_updated_by_fkey\"","alter table \"public\".\"events\" add constraint \"events_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"events\" validate constraint \"events_created_by_fkey\"","alter table \"public\".\"events\" add constraint \"events_place_id_fkey\" FOREIGN KEY (place_id) REFERENCES places(id) ON UPDATE CASCADE not valid","alter table \"public\".\"events\" validate constraint \"events_place_id_fkey\"","alter table \"public\".\"events\" add constraint \"events_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"events\" validate constraint \"events_updated_by_fkey\"","alter table \"public\".\"places\" add constraint \"places_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"places\" validate constraint \"places_created_by_fkey\"","alter table \"public\".\"places\" add constraint \"places_town_id_fkey\" FOREIGN KEY (town_id) REFERENCES towns(id) ON UPDATE CASCADE not valid","alter table \"public\".\"places\" validate constraint \"places_town_id_fkey\"","alter table \"public\".\"places\" add constraint \"places_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"places\" validate constraint \"places_updated_by_fkey\"","alter table \"public\".\"towns\" add constraint \"towns_country_id_fkey\" FOREIGN KEY (country_id) REFERENCES countries(id) ON UPDATE CASCADE not valid","alter table \"public\".\"towns\" validate constraint \"towns_country_id_fkey\"","alter table \"public\".\"towns\" add constraint \"towns_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"towns\" validate constraint \"towns_created_by_fkey\"","alter table \"public\".\"towns\" add constraint \"towns_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"towns\" validate constraint \"towns_updated_by_fkey\"","alter table \"public\".\"authors\" add constraint \"authors_birth_town_fkey\" FOREIGN KEY (birth_town) REFERENCES towns(id) ON UPDATE CASCADE not valid","alter table \"public\".\"authors\" validate constraint \"authors_birth_town_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_event_id_fkey\" FOREIGN KEY (event_id) REFERENCES events(id) ON UPDATE CASCADE not valid","alter table \"public\".\"citations\" validate constraint \"citations_event_id_fkey\"","alter table \"public\".\"citations\" add constraint \"citations_place_id_fkey\" FOREIGN KEY (place_id) REFERENCES places(id) not valid","alter table \"public\".\"citations\" validate constraint \"citations_place_id_fkey\"","set check_function_bodies = off","create policy \"RLS: countries: delete\"
on \"public\".\"countries\"
as permissive
for delete
to authenticated
using (rls_countries_delete(countries.*))","CREATE TRIGGER on_authors_edit_fill_update BEFORE UPDATE ON public.authors FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_authors_new_fill_created_by BEFORE INSERT ON public.authors FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_citations_edit_fill_update BEFORE UPDATE ON public.citations FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_citations_new_fill_created_by BEFORE INSERT ON public.citations FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_events_edit_fill_update BEFORE UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_events_new_fill_created_by BEFORE INSERT ON public.events FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_places_edit_fill_update BEFORE UPDATE ON public.places FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_places_new_fill_created_by BEFORE INSERT ON public.places FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_towns_edit_fill_update BEFORE UPDATE ON public.towns FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_towns_new_fill_created_by BEFORE INSERT ON public.towns FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()"}', 'content_tables_add_created_and_updated_by'),
	('20231225000431', '{"drop policy \"RLS: countries: update\" on \"public\".\"countries\"","alter table \"public\".\"authors\" enable row level security","alter table \"public\".\"citations\" enable row level security","alter table \"public\".\"events\" enable row level security","alter table \"public\".\"places\" enable row level security","alter table \"public\".\"towns\" enable row level security","alter table \"public\".\"towns\" add constraint \"towns_name_check\" CHECK ((length(name) > 0)) not valid","alter table \"public\".\"towns\" validate constraint \"towns_name_check\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.rls_authors_delete(record authors)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_authors_edit(record authors)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_citations_delete(record citations)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_citations_edit(record citations)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_events_delete(record events)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_events_edit(record events)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_places_delete(record places)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_places_edit(record places)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_towns_delete(record towns)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_towns_edit(record towns)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.delete_claim(uid uuid, claim text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''error: access denied'';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data - claim where id = uid;
        return ''OK'';
      END IF;
    END;
$function$","CREATE OR REPLACE FUNCTION public.get_my_claim(claim text)
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting(''request.jwt.claims'', true), '''')::jsonb -> ''app_metadata'' -> claim, null)
$function$","CREATE OR REPLACE FUNCTION public.get_my_claims()
 RETURNS jsonb
 LANGUAGE sql
 STABLE
AS $function$
  select 
  	coalesce(nullif(current_setting(''request.jwt.claims'', true), '''')::jsonb -> ''app_metadata'', ''{}''::jsonb)::jsonb
$function$","CREATE OR REPLACE FUNCTION public.is_claims_admin()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
  BEGIN
    IF session_user = ''authenticator'' THEN
      --------------------------------------------
      -- To disallow any authenticated app users
      -- from editing claims, delete the following
      -- block of code and replace it with:
      -- RETURN FALSE;
      --------------------------------------------
      IF extract(epoch from now()) > coalesce((current_setting(''request.jwt.claims'', true)::jsonb)->>''exp'', ''0'')::numeric THEN
        return false; -- jwt expired
      END IF;
      If current_setting(''request.jwt.claims'', true)::jsonb->>''role'' = ''service_role'' THEN
        RETURN true; -- service role users have admin rights
      END IF;
      IF coalesce((current_setting(''request.jwt.claims'', true)::jsonb)->''app_metadata''->''claims_admin'', ''false'')::bool THEN
        return true; -- user has claims_admin set to true
      ELSE
        return false; -- user does NOT have claims_admin set to true
      END IF;
      --------------------------------------------
      -- End of block 
      --------------------------------------------
    ELSE -- not a user session, probably being called from a trigger or something
      return true;
    END IF;
  END;
$function$","create or replace view \"public\".\"rls_edit_for_table\" as  SELECT ''profiles''::text AS table_name,
    profiles.id,
    rls_profiles_edit(profiles.*) AS editable,
    false AS deletable
   FROM profiles
UNION
 SELECT ''countries''::text AS table_name,
    countries.id,
    rls_countries_edit(countries.*) AS editable,
    rls_countries_delete(countries.*) AS deletable
   FROM countries
UNION
 SELECT ''towns''::text AS table_name,
    towns.id,
    rls_towns_edit(towns.*) AS editable,
    rls_towns_delete(towns.*) AS deletable
   FROM towns","CREATE OR REPLACE FUNCTION public.set_claim(uid uuid, claim text, value jsonb)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''public''
AS $function$
    BEGIN
      IF NOT is_claims_admin() THEN
          RETURN ''error: access denied'';
      ELSE        
        update auth.users set raw_app_meta_data = 
          raw_app_meta_data || 
            json_build_object(claim, value)::jsonb where id = uid;
        return ''OK'';
      END IF;
    END;
$function$","create policy \"RLS: authors: delete\"
on \"public\".\"authors\"
as permissive
for delete
to authenticated
using (rls_authors_edit(authors.*))","create policy \"RLS: authors: insert\"
on \"public\".\"authors\"
as permissive
for insert
to authenticated
with check (rls_authors_edit(authors.*))","create policy \"RLS: authors: select\"
on \"public\".\"authors\"
as permissive
for select
to public
using (true)","create policy \"RLS: authors: update\"
on \"public\".\"authors\"
as permissive
for update
to authenticated
using (rls_authors_edit(authors.*))
with check (rls_authors_edit(authors.*))","create policy \"RLS: citations: delete\"
on \"public\".\"citations\"
as permissive
for delete
to authenticated
using (rls_citations_edit(citations.*))","create policy \"RLS: citations: insert\"
on \"public\".\"citations\"
as permissive
for insert
to authenticated
with check (rls_citations_edit(citations.*))","create policy \"RLS: citations: select\"
on \"public\".\"citations\"
as permissive
for select
to public
using (true)","create policy \"RLS: citations: update\"
on \"public\".\"citations\"
as permissive
for update
to authenticated
using (rls_citations_edit(citations.*))
with check (rls_citations_edit(citations.*))","create policy \"RLS: events: delete\"
on \"public\".\"events\"
as permissive
for delete
to authenticated
using (rls_events_edit(events.*))","create policy \"RLS: events: insert\"
on \"public\".\"events\"
as permissive
for insert
to authenticated
with check (rls_events_edit(events.*))","create policy \"RLS: events: select\"
on \"public\".\"events\"
as permissive
for select
to public
using (true)","create policy \"RLS: events: update\"
on \"public\".\"events\"
as permissive
for update
to authenticated
using (rls_events_edit(events.*))
with check (rls_events_edit(events.*))","create policy \"RLS: places: delete\"
on \"public\".\"places\"
as permissive
for delete
to authenticated
using (rls_places_edit(places.*))","create policy \"RLS: places: insert\"
on \"public\".\"places\"
as permissive
for insert
to authenticated
with check (rls_places_edit(places.*))","create policy \"RLS: places: select\"
on \"public\".\"places\"
as permissive
for select
to public
using (true)","create policy \"RLS: places: update\"
on \"public\".\"places\"
as permissive
for update
to authenticated
using (rls_places_edit(places.*))
with check (rls_places_edit(places.*))","create policy \"RLS: towns: delete\"
on \"public\".\"towns\"
as permissive
for delete
to authenticated
using (rls_towns_edit(towns.*))","create policy \"RLS: towns: insert\"
on \"public\".\"towns\"
as permissive
for insert
to authenticated
with check (rls_towns_edit(towns.*))","create policy \"RLS: towns: select\"
on \"public\".\"towns\"
as permissive
for select
to public
using (true)","create policy \"RLS: towns: update\"
on \"public\".\"towns\"
as permissive
for update
to authenticated
using (rls_towns_edit(towns.*))
with check (rls_towns_edit(towns.*))","create policy \"RLS: countries: update\"
on \"public\".\"countries\"
as permissive
for update
to authenticated
using (rls_countries_edit(countries.*))
with check (rls_countries_edit(countries.*))"}', 'content_tables_add_rls'),
	('20231225013536', '{"drop policy \"Public profiles are viewable by everyone.\" on \"public\".\"profiles\"","drop policy \"Users can insert their own profile.\" on \"public\".\"profiles\"","drop policy \"Users can update own profile.\" on \"public\".\"profiles\"","drop policy \"Enable read access for all users\" on \"public\".\"trusts\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.rls_trusts_edit(record trusts)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- RAISE LOG ''rls_profiles_edit: profile %'', record.id;
    RETURN rls_check_edit_by_created_by(record.who, FALSE, ''claim_edit_all_profiles'');
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_profiles_edit(record profiles)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- RAISE LOG ''rls_profiles_edit: profile %'', record.id;
    RETURN rls_check_edit_by_created_by(record.id, FALSE, ''claim_edit_all_profiles'');
END;
$function$","create or replace view \"public\".\"rls_edit_for_table\" as  SELECT ''authors''::text AS table_name,
    authors.id,
    rls_authors_edit(authors.*) AS editable,
    rls_authors_delete(authors.*) AS deletable
   FROM authors
UNION
 SELECT ''citations''::text AS table_name,
    citations.id,
    rls_citations_edit(citations.*) AS editable,
    rls_citations_delete(citations.*) AS deletable
   FROM citations
UNION
 SELECT ''countries''::text AS table_name,
    countries.id,
    rls_countries_edit(countries.*) AS editable,
    rls_countries_delete(countries.*) AS deletable
   FROM countries
UNION
 SELECT ''events''::text AS table_name,
    events.id,
    rls_events_edit(events.*) AS editable,
    rls_events_delete(events.*) AS deletable
   FROM events
UNION
 SELECT ''places''::text AS table_name,
    places.id,
    rls_places_edit(places.*) AS editable,
    rls_places_delete(places.*) AS deletable
   FROM places
UNION
 SELECT ''profiles''::text AS table_name,
    profiles.id,
    rls_profiles_edit(profiles.*) AS editable,
    false AS deletable
   FROM profiles
UNION
 SELECT ''towns''::text AS table_name,
    towns.id,
    rls_towns_edit(towns.*) AS editable,
    rls_towns_delete(towns.*) AS deletable
   FROM towns
UNION
 SELECT ''trusts''::text AS table_name,
    trusts.id,
    rls_trusts_edit(trusts.*) AS editable,
    rls_trusts_edit(trusts.*) AS deletable
   FROM trusts","create policy \" RLS: profiles: insert\"
on \"public\".\"profiles\"
as permissive
for insert
to public
with check ((auth.uid() = auth_user_id))","create policy \" RLS: profiles: update\"
on \"public\".\"profiles\"
as permissive
for update
to public
using (rls_profiles_edit(profiles.*))","create policy \"RLS: profiles: select\"
on \"public\".\"profiles\"
as permissive
for select
to public
using (true)","create policy \"RLS: trusts: delete\"
on \"public\".\"trusts\"
as permissive
for delete
to authenticated
using (rls_trusts_edit(trusts.*))","create policy \"RLS: trusts: insert\"
on \"public\".\"trusts\"
as permissive
for insert
to authenticated
with check (rls_trusts_edit(trusts.*))","create policy \"RLS: trusts: select\"
on \"public\".\"trusts\"
as permissive
for select
to authenticated
using (true)","create policy \"RLS: trusts: update\"
on \"public\".\"trusts\"
as permissive
for update
to authenticated
using (rls_trusts_edit(trusts.*))
with check (rls_trusts_edit(trusts.*))"}', 'profiles_tables_add_rls'),
	('20231225224033', '{"drop view if exists \"public\".\"rls_edit_for_table\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length
      THEN substring(s, 1, max_length - 3) || ''...''
      ELSE s
      END;
END;
$function$","create or replace view \"public\".\"view_id_name\" as  SELECT ''authors''::text AS table_name,
    authors.id,
    authors.lastname_name_patronymic AS name,
    string_limit((authors.lastname_name_patronymic)::character varying, 20) AS short_name
   FROM authors
UNION
 SELECT ''citations''::text AS table_name,
    citations.id,
    string_limit((citations.english_text)::character varying, 40) AS name,
    string_limit((citations.english_text)::character varying, 20) AS short_name
   FROM citations
UNION
 SELECT ''countries''::text AS table_name,
    countries.id,
    countries.name,
    string_limit((countries.name)::character varying, 20) AS short_name
   FROM countries
UNION
 SELECT ''places''::text AS table_name,
    places.id,
    places.name,
    string_limit((places.name)::character varying, 20) AS short_name
   FROM places
UNION
 SELECT ''profiles''::text AS table_name,
    profiles.id,
    (((profiles.full_name || '' (''::text) || profiles.username) || '')''::text) AS name,
    profiles.username AS short_name
   FROM profiles
UNION
 SELECT ''towns''::text AS table_name,
    towns.id,
    towns.name,
    string_limit((towns.name)::character varying, 20) AS short_name
   FROM towns","create or replace view \"public\".\"view_rls_edit_for_table\" as  SELECT ''authors''::text AS table_name,
    authors.id,
    rls_authors_edit(authors.*) AS editable,
    rls_authors_delete(authors.*) AS deletable
   FROM authors
UNION
 SELECT ''citations''::text AS table_name,
    citations.id,
    rls_citations_edit(citations.*) AS editable,
    rls_citations_delete(citations.*) AS deletable
   FROM citations
UNION
 SELECT ''countries''::text AS table_name,
    countries.id,
    rls_countries_edit(countries.*) AS editable,
    rls_countries_delete(countries.*) AS deletable
   FROM countries
UNION
 SELECT ''events''::text AS table_name,
    events.id,
    rls_events_edit(events.*) AS editable,
    rls_events_delete(events.*) AS deletable
   FROM events
UNION
 SELECT ''places''::text AS table_name,
    places.id,
    rls_places_edit(places.*) AS editable,
    rls_places_delete(places.*) AS deletable
   FROM places
UNION
 SELECT ''profiles''::text AS table_name,
    profiles.id,
    rls_profiles_edit(profiles.*) AS editable,
    false AS deletable
   FROM profiles
UNION
 SELECT ''towns''::text AS table_name,
    towns.id,
    rls_towns_edit(towns.*) AS editable,
    rls_towns_delete(towns.*) AS deletable
   FROM towns
UNION
 SELECT ''trusts''::text AS table_name,
    trusts.id,
    rls_trusts_edit(trusts.*) AS editable,
    rls_trusts_edit(trusts.*) AS deletable
   FROM trusts"}', 'view_id_name'),
	('20240114152304', '{"drop trigger if exists \"on_authors_edit_fill_update\" on \"public\".\"authors\"","drop trigger if exists \"on_authors_new_fill_created_by\" on \"public\".\"authors\"","drop trigger if exists \"on_citations_edit_fill_update\" on \"public\".\"citations\"","drop trigger if exists \"on_citations_new_fill_created_by\" on \"public\".\"citations\"","drop trigger if exists \"on_country_edit_fill_update\" on \"public\".\"countries\"","drop trigger if exists \"on_country_new_fill_created_by\" on \"public\".\"countries\"","drop trigger if exists \"on_events_edit_fill_update\" on \"public\".\"events\"","drop trigger if exists \"on_events_new_fill_created_by\" on \"public\".\"events\"","drop trigger if exists \"on_places_edit_fill_update\" on \"public\".\"places\"","drop trigger if exists \"on_places_new_fill_created_by\" on \"public\".\"places\"","drop trigger if exists \"on_public_profiles_new\" on \"public\".\"profiles\"","drop trigger if exists \"on_towns_edit_fill_update\" on \"public\".\"towns\"","drop trigger if exists \"on_towns_new_fill_created_by\" on \"public\".\"towns\"","drop policy \"RLS: authors: delete\" on \"public\".\"authors\"","drop policy \"RLS: authors: insert\" on \"public\".\"authors\"","drop policy \"RLS: authors: select\" on \"public\".\"authors\"","drop policy \"RLS: authors: update\" on \"public\".\"authors\"","drop policy \"RLS: citations: delete\" on \"public\".\"citations\"","drop policy \"RLS: citations: insert\" on \"public\".\"citations\"","drop policy \"RLS: citations: select\" on \"public\".\"citations\"","drop policy \"RLS: citations: update\" on \"public\".\"citations\"","drop policy \"RLS: countries: delete\" on \"public\".\"countries\"","drop policy \"RLS: countries: insert\" on \"public\".\"countries\"","drop policy \"RLS: countries: select\" on \"public\".\"countries\"","drop policy \"RLS: countries: update\" on \"public\".\"countries\"","drop policy \"RLS: events: delete\" on \"public\".\"events\"","drop policy \"RLS: events: insert\" on \"public\".\"events\"","drop policy \"RLS: events: select\" on \"public\".\"events\"","drop policy \"RLS: events: update\" on \"public\".\"events\"","drop policy \"RLS: places: delete\" on \"public\".\"places\"","drop policy \"RLS: places: insert\" on \"public\".\"places\"","drop policy \"RLS: places: select\" on \"public\".\"places\"","drop policy \"RLS: places: update\" on \"public\".\"places\"","drop policy \" RLS: profiles: insert\" on \"public\".\"profiles\"","drop policy \" RLS: profiles: update\" on \"public\".\"profiles\"","drop policy \"RLS: profiles: select\" on \"public\".\"profiles\"","drop policy \"RLS: towns: delete\" on \"public\".\"towns\"","drop policy \"RLS: towns: insert\" on \"public\".\"towns\"","drop policy \"RLS: towns: select\" on \"public\".\"towns\"","drop policy \"RLS: towns: update\" on \"public\".\"towns\"","drop policy \"RLS: trusts: delete\" on \"public\".\"trusts\"","drop policy \"RLS: trusts: insert\" on \"public\".\"trusts\"","drop policy \"RLS: trusts: select\" on \"public\".\"trusts\"","drop policy \"RLS: trusts: update\" on \"public\".\"trusts\"","alter table \"public\".\"authors\" drop constraint \"authors_birth_town_fkey\"","alter table \"public\".\"authors\" drop constraint \"authors_created_by_fkey\"","alter table \"public\".\"authors\" drop constraint \"authors_updated_by_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_author_id_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_created_by_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_event_id_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_place_id_fkey\"","alter table \"public\".\"citations\" drop constraint \"citations_updated_by_fkey\"","alter table \"public\".\"countries\" drop constraint \"countries_created_by_fkey\"","alter table \"public\".\"countries\" drop constraint \"countries_name_check\"","alter table \"public\".\"countries\" drop constraint \"countries_name_key\"","alter table \"public\".\"countries\" drop constraint \"countries_updated_by_fkey\"","alter table \"public\".\"events\" drop constraint \"events_created_by_fkey\"","alter table \"public\".\"events\" drop constraint \"events_place_id_fkey\"","alter table \"public\".\"events\" drop constraint \"events_updated_by_fkey\"","alter table \"public\".\"places\" drop constraint \"places_created_by_fkey\"","alter table \"public\".\"places\" drop constraint \"places_town_id_fkey\"","alter table \"public\".\"places\" drop constraint \"places_updated_by_fkey\"","alter table \"public\".\"profiles\" drop constraint \"profiles_id_fkey\"","alter table \"public\".\"profiles\" drop constraint \"profiles_username_key\"","alter table \"public\".\"profiles\" drop constraint \"username_length\"","alter table \"public\".\"towns\" drop constraint \"towns_country_id_fkey\"","alter table \"public\".\"towns\" drop constraint \"towns_created_by_fkey\"","alter table \"public\".\"towns\" drop constraint \"towns_name_check\"","alter table \"public\".\"towns\" drop constraint \"towns_updated_by_fkey\"","drop function if exists \"public\".\"rls_profiles_edit\"(records profiles[])","drop view if exists \"public\".\"view_id_name\"","drop view if exists \"public\".\"view_rls_edit_for_table\"","drop function if exists \"public\".\"rls_authors_delete\"(record authors)","drop function if exists \"public\".\"rls_authors_edit\"(record authors)","drop function if exists \"public\".\"rls_citations_delete\"(record citations)","drop function if exists \"public\".\"rls_citations_edit\"(record citations)","drop function if exists \"public\".\"rls_countries_delete\"(record countries)","drop function if exists \"public\".\"rls_countries_edit\"(record countries)","drop function if exists \"public\".\"rls_events_delete\"(record events)","drop function if exists \"public\".\"rls_events_edit\"(record events)","drop function if exists \"public\".\"rls_places_delete\"(record places)","drop function if exists \"public\".\"rls_places_edit\"(record places)","drop function if exists \"public\".\"rls_profiles_edit\"(record profiles)","drop function if exists \"public\".\"rls_towns_delete\"(record towns)","drop function if exists \"public\".\"rls_towns_edit\"(record towns)","drop function if exists \"public\".\"rls_trusts_edit\"(record trusts)","alter table \"public\".\"authors\" drop constraint \"author_pkey\"","alter table \"public\".\"citations\" drop constraint \"citations_pkey\"","alter table \"public\".\"countries\" drop constraint \"country_pkey\"","alter table \"public\".\"events\" drop constraint \"event_pkey\"","alter table \"public\".\"places\" drop constraint \"place_pkey\"","alter table \"public\".\"profiles\" drop constraint \"profiles_pkey\"","alter table \"public\".\"towns\" drop constraint \"town_pkey\"","alter table \"public\".\"trusts\" drop constraint \"trusts_pkey\"","drop index if exists \"public\".\"author_pkey\"","drop index if exists \"public\".\"citations_pkey\"","drop index if exists \"public\".\"countries_name_key\"","drop index if exists \"public\".\"country_pkey\"","drop index if exists \"public\".\"event_pkey\"","drop index if exists \"public\".\"place_pkey\"","drop index if exists \"public\".\"profiles_pkey\"","drop index if exists \"public\".\"profiles_username_key\"","drop index if exists \"public\".\"town_pkey\"","drop index if exists \"public\".\"trusts_pkey\"","drop table \"public\".\"authors\"","drop table \"public\".\"citations\"","drop table \"public\".\"countries\"","drop table \"public\".\"events\"","drop table \"public\".\"places\"","drop table \"public\".\"profiles\"","drop table \"public\".\"towns\"","drop table \"public\".\"trusts\"","create table \"public\".\"author\" (
    \"id\" bigint generated by default as identity not null,
    \"lastname_name_patronymic\" text not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"birth_year\" bigint,
    \"death_year\" bigint,
    \"approximate_years\" boolean not null default false,
    \"updated_at\" timestamp with time zone not null default now(),
    \"birth_town\" bigint,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"author\" enable row level security","create table \"public\".\"citation\" (
    \"id\" bigint generated by default as identity not null,
    \"english_text\" text,
    \"author_id\" bigint not null,
    \"year\" bigint,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp without time zone not null default now(),
    \"original_language_text\" text,
    \"place_id\" bigint,
    \"event_id\" bigint,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"citation\" enable row level security","create table \"public\".\"content_item\" (
    \"table_name\" text not null,
    \"id\" bigint not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"created_by\" bigint,
    \"updated_at\" timestamp with time zone,
    \"updated_by\" bigint,
    \"published_at\" timestamp with time zone,
    \"published_by\" bigint,
    \"unpublished_at\" timestamp with time zone,
    \"unpublished_by\" bigint
)","create table \"public\".\"country\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null default ''''::text,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone default now(),
    \"found_year\" bigint,
    \"next_rename_year\" bigint,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"country\" enable row level security","create table \"public\".\"event\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"start_year\" bigint not null,
    \"start_month\" smallint not null,
    \"end_year\" bigint,
    \"end_month\" smallint,
    \"place_id\" bigint,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"event\" enable row level security","create table \"public\".\"place\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null default ''in''::text,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"town_id\" bigint not null,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"place\" enable row level security","create table \"public\".\"profile\" (
    \"auth_user_id\" uuid not null,
    \"updated_at\" timestamp with time zone,
    \"username\" text,
    \"full_name\" text,
    \"avatar_url\" text,
    \"website\" text,
    \"id\" bigint generated by default as identity not null,
    \"created_at\" timestamp with time zone default now()
)","alter table \"public\".\"profile\" enable row level security","create table \"public\".\"town\" (
    \"id\" bigint generated by default as identity not null,
    \"name\" text not null,
    \"created_at\" timestamp with time zone not null default now(),
    \"updated_at\" timestamp with time zone not null default now(),
    \"country_id\" bigint not null,
    \"created_by\" bigint,
    \"updated_by\" bigint
)","alter table \"public\".\"town\" enable row level security","create table \"public\".\"trust\" (
    \"id\" bigint generated by default as identity not null,
    \"who\" bigint not null,
    \"trusts_whom\" bigint not null,
    \"end_at\" timestamp with time zone not null default (now() + ''1 day''::interval)
)","alter table \"public\".\"trust\" enable row level security","CREATE UNIQUE INDEX content_item_pkey ON public.content_item USING btree (table_name, id)","CREATE UNIQUE INDEX author_pkey ON public.author USING btree (id)","CREATE UNIQUE INDEX citations_pkey ON public.citation USING btree (id)","CREATE UNIQUE INDEX countries_name_key ON public.country USING btree (name)","CREATE UNIQUE INDEX country_pkey ON public.country USING btree (id)","CREATE UNIQUE INDEX event_pkey ON public.event USING btree (id)","CREATE UNIQUE INDEX place_pkey ON public.place USING btree (id)","CREATE UNIQUE INDEX profiles_pkey ON public.profile USING btree (id)","CREATE UNIQUE INDEX profiles_username_key ON public.profile USING btree (username)","CREATE UNIQUE INDEX town_pkey ON public.town USING btree (id)","CREATE UNIQUE INDEX trusts_pkey ON public.trust USING btree (id)","alter table \"public\".\"author\" add constraint \"author_pkey\" PRIMARY KEY using index \"author_pkey\"","alter table \"public\".\"citation\" add constraint \"citations_pkey\" PRIMARY KEY using index \"citations_pkey\"","alter table \"public\".\"content_item\" add constraint \"content_item_pkey\" PRIMARY KEY using index \"content_item_pkey\"","alter table \"public\".\"country\" add constraint \"country_pkey\" PRIMARY KEY using index \"country_pkey\"","alter table \"public\".\"event\" add constraint \"event_pkey\" PRIMARY KEY using index \"event_pkey\"","alter table \"public\".\"place\" add constraint \"place_pkey\" PRIMARY KEY using index \"place_pkey\"","alter table \"public\".\"profile\" add constraint \"profiles_pkey\" PRIMARY KEY using index \"profiles_pkey\"","alter table \"public\".\"town\" add constraint \"town_pkey\" PRIMARY KEY using index \"town_pkey\"","alter table \"public\".\"trust\" add constraint \"trusts_pkey\" PRIMARY KEY using index \"trusts_pkey\"","alter table \"public\".\"author\" add constraint \"author_birth_town_fkey\" FOREIGN KEY (birth_town) REFERENCES town(id) ON UPDATE CASCADE not valid","alter table \"public\".\"author\" validate constraint \"author_birth_town_fkey\"","alter table \"public\".\"author\" add constraint \"author_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"author\" validate constraint \"author_created_by_fkey\"","alter table \"public\".\"author\" add constraint \"author_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"author\" validate constraint \"author_updated_by_fkey\"","alter table \"public\".\"citation\" add constraint \"citation_author_id_fkey\" FOREIGN KEY (author_id) REFERENCES author(id) ON UPDATE CASCADE not valid","alter table \"public\".\"citation\" validate constraint \"citation_author_id_fkey\"","alter table \"public\".\"citation\" add constraint \"citation_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"citation\" validate constraint \"citation_created_by_fkey\"","alter table \"public\".\"citation\" add constraint \"citation_event_id_fkey\" FOREIGN KEY (event_id) REFERENCES event(id) ON UPDATE CASCADE not valid","alter table \"public\".\"citation\" validate constraint \"citation_event_id_fkey\"","alter table \"public\".\"citation\" add constraint \"citation_place_id_fkey\" FOREIGN KEY (place_id) REFERENCES place(id) not valid","alter table \"public\".\"citation\" validate constraint \"citation_place_id_fkey\"","alter table \"public\".\"citation\" add constraint \"citation_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"citation\" validate constraint \"citation_updated_by_fkey\"","alter table \"public\".\"country\" add constraint \"countries_name_check\" CHECK ((length(name) > 0)) not valid","alter table \"public\".\"country\" validate constraint \"countries_name_check\"","alter table \"public\".\"country\" add constraint \"countries_name_key\" UNIQUE using index \"countries_name_key\"","alter table \"public\".\"country\" add constraint \"country_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"country\" validate constraint \"country_created_by_fkey\"","alter table \"public\".\"country\" add constraint \"country_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"country\" validate constraint \"country_updated_by_fkey\"","alter table \"public\".\"event\" add constraint \"event_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"event\" validate constraint \"event_created_by_fkey\"","alter table \"public\".\"event\" add constraint \"event_place_id_fkey\" FOREIGN KEY (place_id) REFERENCES place(id) ON UPDATE CASCADE not valid","alter table \"public\".\"event\" validate constraint \"event_place_id_fkey\"","alter table \"public\".\"event\" add constraint \"event_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"event\" validate constraint \"event_updated_by_fkey\"","alter table \"public\".\"place\" add constraint \"place_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"place\" validate constraint \"place_created_by_fkey\"","alter table \"public\".\"place\" add constraint \"place_town_id_fkey\" FOREIGN KEY (town_id) REFERENCES town(id) ON UPDATE CASCADE not valid","alter table \"public\".\"place\" validate constraint \"place_town_id_fkey\"","alter table \"public\".\"place\" add constraint \"place_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"place\" validate constraint \"place_updated_by_fkey\"","alter table \"public\".\"profile\" add constraint \"profile_auth_user_id_fkey\" FOREIGN KEY (auth_user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid","alter table \"public\".\"profile\" validate constraint \"profile_auth_user_id_fkey\"","alter table \"public\".\"profile\" add constraint \"profiles_username_key\" UNIQUE using index \"profiles_username_key\"","alter table \"public\".\"profile\" add constraint \"username_length\" CHECK ((char_length(username) >= 3)) not valid","alter table \"public\".\"profile\" validate constraint \"username_length\"","alter table \"public\".\"town\" add constraint \"town_country_id_fkey\" FOREIGN KEY (country_id) REFERENCES country(id) ON UPDATE CASCADE not valid","alter table \"public\".\"town\" validate constraint \"town_country_id_fkey\"","alter table \"public\".\"town\" add constraint \"town_created_by_fkey\" FOREIGN KEY (created_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"town\" validate constraint \"town_created_by_fkey\"","alter table \"public\".\"town\" add constraint \"town_updated_by_fkey\" FOREIGN KEY (updated_by) REFERENCES profile(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid","alter table \"public\".\"town\" validate constraint \"town_updated_by_fkey\"","alter table \"public\".\"town\" add constraint \"towns_name_check\" CHECK ((length(name) > 0)) not valid","alter table \"public\".\"town\" validate constraint \"towns_name_check\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.rls_authors_delete(record author)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_authors_edit(record author)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_citations_delete(record citation)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_citations_edit(record citation)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_countries_delete(record country)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_countries_edit(record country)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_events_delete(record event)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_events_edit(record event)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_places_delete(record place)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_places_edit(record place)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_profiles_edit(record profile)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- RAISE LOG ''rls_profiles_edit: profile %'', record.id;
    RETURN rls_check_edit_by_created_by(record.id, FALSE, ''claim_edit_all_profiles'');
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_profiles_edit(records profile[])
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    t profiles;
BEGIN
  FOREACH t IN ARRAY records LOOP
    RAISE LOG ''rls_profiles_edit: profiles %'', t.id;
    RETURN TRUE;
  END LOOP;
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_towns_delete(record town)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_towns_edit(record town)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_trusts_edit(record trust)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- RAISE LOG ''rls_profiles_edit: profile %'', record.id;
    RETURN rls_check_edit_by_created_by(record.who, FALSE, ''claim_edit_all_profiles'');
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_auth_user_new()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profile (auth_user_id, full_name, avatar_url)
	  VALUES (
		  NEW.id,
		  NEW.raw_user_meta_data->>''full_name'',
		  NEW.raw_user_meta_data->>''avatar_url''
	  );
  RETURN NEW;
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_check_edit_by_created_by(created_by bigint, allow_trust boolean DEFAULT true, claim_check character varying DEFAULT ''claim_edit_all_content''::character varying)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
	profile_id int8;
BEGIN
  profile_id := get_my_claim(''profile_id'')::int;
	-- RAISE WARNING ''rls_check_by_created_by: created_by: %, profile_id: %'', created_by, profile_id;
	-- RETURN TRUE;
	RETURN get_my_claim(claim_check)::varchar::boolean
	    OR (profile_id = created_by)
	   	OR (
				allow_trust AND ((
					SELECT TRUE
					FROM trust
					WHERE NOW() < trust.end_at
					AND created_by = trust.who
						AND profile_id = trust.trusts_whom
				))
			);
END;
$function$","CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length 
      THEN substring(s, 1, max_length - 3) || ''...'' 
      ELSE s
      END;
END;
$function$","create or replace view \"public\".\"view_id_name\" as  SELECT ''author''::text AS table_name,
    author.id,
    author.lastname_name_patronymic AS name,
    string_limit((author.lastname_name_patronymic)::character varying, 20) AS short_name
   FROM author
UNION
 SELECT ''citation''::text AS table_name,
    citation.id,
    string_limit((citation.english_text)::character varying, 40) AS name,
    string_limit((citation.english_text)::character varying, 20) AS short_name
   FROM citation
UNION
 SELECT ''country''::text AS table_name,
    country.id,
    country.name,
    string_limit((country.name)::character varying, 20) AS short_name
   FROM country
UNION
 SELECT ''place''::text AS table_name,
    place.id,
    place.name,
    string_limit((place.name)::character varying, 20) AS short_name
   FROM place
UNION
 SELECT ''profile''::text AS table_name,
    profile.id,
    (((profile.full_name || '' (''::text) || profile.username) || '')''::text) AS name,
    profile.username AS short_name
   FROM profile
UNION
 SELECT ''town''::text AS table_name,
    town.id,
    town.name,
    string_limit((town.name)::character varying, 20) AS short_name
   FROM town
  ORDER BY 1, 4","create or replace view \"public\".\"view_rls_edit_for_table\" as  SELECT ''authors''::text AS table_name,
    author.id,
    rls_authors_edit(author.*) AS editable,
    rls_authors_delete(author.*) AS deletable
   FROM author
UNION
 SELECT ''citations''::text AS table_name,
    citation.id,
    rls_citations_edit(citation.*) AS editable,
    rls_citations_delete(citation.*) AS deletable
   FROM citation
UNION
 SELECT ''countries''::text AS table_name,
    country.id,
    rls_countries_edit(country.*) AS editable,
    rls_countries_delete(country.*) AS deletable
   FROM country
UNION
 SELECT ''events''::text AS table_name,
    event.id,
    rls_events_edit(event.*) AS editable,
    rls_events_delete(event.*) AS deletable
   FROM event
UNION
 SELECT ''places''::text AS table_name,
    place.id,
    rls_places_edit(place.*) AS editable,
    rls_places_delete(place.*) AS deletable
   FROM place
UNION
 SELECT ''profiles''::text AS table_name,
    profile.id,
    rls_profiles_edit(profile.*) AS editable,
    false AS deletable
   FROM profile
UNION
 SELECT ''towns''::text AS table_name,
    town.id,
    rls_towns_edit(town.*) AS editable,
    rls_towns_delete(town.*) AS deletable
   FROM town
UNION
 SELECT ''trusts''::text AS table_name,
    trust.id,
    rls_trusts_edit(trust.*) AS editable,
    rls_trusts_edit(trust.*) AS deletable
   FROM trust","create policy \"RLS: authors: delete\"
on \"public\".\"author\"
as permissive
for delete
to authenticated
using (rls_authors_edit(author.*))","create policy \"RLS: authors: insert\"
on \"public\".\"author\"
as permissive
for insert
to authenticated
with check (rls_authors_edit(author.*))","create policy \"RLS: authors: select\"
on \"public\".\"author\"
as permissive
for select
to public
using (true)","create policy \"RLS: authors: update\"
on \"public\".\"author\"
as permissive
for update
to authenticated
using (rls_authors_edit(author.*))
with check (rls_authors_edit(author.*))","create policy \"RLS: citations: delete\"
on \"public\".\"citation\"
as permissive
for delete
to authenticated
using (rls_citations_edit(citation.*))","create policy \"RLS: citations: insert\"
on \"public\".\"citation\"
as permissive
for insert
to authenticated
with check (rls_citations_edit(citation.*))","create policy \"RLS: citations: select\"
on \"public\".\"citation\"
as permissive
for select
to public
using (true)","create policy \"RLS: citations: update\"
on \"public\".\"citation\"
as permissive
for update
to authenticated
using (rls_citations_edit(citation.*))
with check (rls_citations_edit(citation.*))","create policy \"RLS: countries: delete\"
on \"public\".\"country\"
as permissive
for delete
to authenticated
using (rls_countries_delete(country.*))","create policy \"RLS: countries: insert\"
on \"public\".\"country\"
as permissive
for insert
to authenticated
with check (rls_countries_edit(country.*))","create policy \"RLS: countries: select\"
on \"public\".\"country\"
as permissive
for select
to public
using (true)","create policy \"RLS: countries: update\"
on \"public\".\"country\"
as permissive
for update
to authenticated
using (rls_countries_edit(country.*))
with check (rls_countries_edit(country.*))","create policy \"RLS: events: delete\"
on \"public\".\"event\"
as permissive
for delete
to authenticated
using (rls_events_edit(event.*))","create policy \"RLS: events: insert\"
on \"public\".\"event\"
as permissive
for insert
to authenticated
with check (rls_events_edit(event.*))","create policy \"RLS: events: select\"
on \"public\".\"event\"
as permissive
for select
to public
using (true)","create policy \"RLS: events: update\"
on \"public\".\"event\"
as permissive
for update
to authenticated
using (rls_events_edit(event.*))
with check (rls_events_edit(event.*))","create policy \"RLS: places: delete\"
on \"public\".\"place\"
as permissive
for delete
to authenticated
using (rls_places_edit(place.*))","create policy \"RLS: places: insert\"
on \"public\".\"place\"
as permissive
for insert
to authenticated
with check (rls_places_edit(place.*))","create policy \"RLS: places: select\"
on \"public\".\"place\"
as permissive
for select
to public
using (true)","create policy \"RLS: places: update\"
on \"public\".\"place\"
as permissive
for update
to authenticated
using (rls_places_edit(place.*))
with check (rls_places_edit(place.*))","create policy \" RLS: profiles: insert\"
on \"public\".\"profile\"
as permissive
for insert
to public
with check ((auth.uid() = auth_user_id))","create policy \" RLS: profiles: update\"
on \"public\".\"profile\"
as permissive
for update
to public
using (rls_profiles_edit(profile.*))","create policy \"RLS: profiles: select\"
on \"public\".\"profile\"
as permissive
for select
to public
using (true)","create policy \"RLS: towns: delete\"
on \"public\".\"town\"
as permissive
for delete
to authenticated
using (rls_towns_edit(town.*))","create policy \"RLS: towns: insert\"
on \"public\".\"town\"
as permissive
for insert
to authenticated
with check (rls_towns_edit(town.*))","create policy \"RLS: towns: select\"
on \"public\".\"town\"
as permissive
for select
to public
using (true)","create policy \"RLS: towns: update\"
on \"public\".\"town\"
as permissive
for update
to authenticated
using (rls_towns_edit(town.*))
with check (rls_towns_edit(town.*))","create policy \"RLS: trusts: delete\"
on \"public\".\"trust\"
as permissive
for delete
to authenticated
using (rls_trusts_edit(trust.*))","create policy \"RLS: trusts: insert\"
on \"public\".\"trust\"
as permissive
for insert
to authenticated
with check (rls_trusts_edit(trust.*))","create policy \"RLS: trusts: select\"
on \"public\".\"trust\"
as permissive
for select
to authenticated
using (true)","create policy \"RLS: trusts: update\"
on \"public\".\"trust\"
as permissive
for update
to authenticated
using (rls_trusts_edit(trust.*))
with check (rls_trusts_edit(trust.*))","CREATE TRIGGER on_authors_edit_fill_update BEFORE UPDATE ON public.author FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_authors_new_fill_created_by BEFORE INSERT ON public.author FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_citations_edit_fill_update BEFORE UPDATE ON public.citation FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_citations_new_fill_created_by BEFORE INSERT ON public.citation FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_country_edit_fill_update BEFORE UPDATE ON public.country FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_country_new_fill_created_by BEFORE INSERT ON public.country FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_events_edit_fill_update BEFORE UPDATE ON public.event FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_events_new_fill_created_by BEFORE INSERT ON public.event FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_places_edit_fill_update BEFORE UPDATE ON public.place FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_places_new_fill_created_by BEFORE INSERT ON public.place FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()","CREATE TRIGGER on_public_profile_new AFTER INSERT ON public.profile FOR EACH ROW EXECUTE FUNCTION handle_public_profile_new()","CREATE TRIGGER on_towns_edit_fill_update BEFORE UPDATE ON public.town FOR EACH ROW EXECUTE FUNCTION handle_fill_updated()","CREATE TRIGGER on_towns_new_fill_created_by BEFORE INSERT ON public.town FOR EACH ROW EXECUTE FUNCTION handle_fill_created_by()"}', 'data_loss_rename_singular_and_content_item'),
	('20240114160552', '{"create or replace view \"public\".\"view_rls_edit_for_table\" as  SELECT ''author''::text AS table_name,
    author.id,
    rls_authors_edit(author.*) AS editable,
    rls_authors_delete(author.*) AS deletable
   FROM author
UNION
 SELECT ''citation''::text AS table_name,
    citation.id,
    rls_citations_edit(citation.*) AS editable,
    rls_citations_delete(citation.*) AS deletable
   FROM citation
UNION
 SELECT ''country''::text AS table_name,
    country.id,
    rls_countries_edit(country.*) AS editable,
    rls_countries_delete(country.*) AS deletable
   FROM country
UNION
 SELECT ''event''::text AS table_name,
    event.id,
    rls_events_edit(event.*) AS editable,
    rls_events_delete(event.*) AS deletable
   FROM event
UNION
 SELECT ''place''::text AS table_name,
    place.id,
    rls_places_edit(place.*) AS editable,
    rls_places_delete(place.*) AS deletable
   FROM place
UNION
 SELECT ''profile''::text AS table_name,
    profile.id,
    rls_profiles_edit(profile.*) AS editable,
    false AS deletable
   FROM profile
UNION
 SELECT ''town''::text AS table_name,
    town.id,
    rls_towns_edit(town.*) AS editable,
    rls_towns_delete(town.*) AS deletable
   FROM town
UNION
 SELECT ''trust''::text AS table_name,
    trust.id,
    rls_trusts_edit(trust.*) AS editable,
    rls_trusts_edit(trust.*) AS deletable
   FROM trust"}', 'view_rls_edit_for_table_fix_after_rename'),
	('20240114230815', '{"drop trigger if exists \"on_country_edit_fill_update\" on \"public\".\"country\"","drop policy \"RLS: countries: delete\" on \"public\".\"country\"","drop policy \"RLS: countries: insert\" on \"public\".\"country\"","drop policy \"RLS: countries: select\" on \"public\".\"country\"","drop policy \"RLS: countries: update\" on \"public\".\"country\"","drop view if exists \"public\".\"view_rls_edit_for_table\"","drop function if exists \"public\".\"rls_countries_delete\"(record country)","drop function if exists \"public\".\"rls_countries_edit\"(record country)","alter table \"public\".\"country\" inherit \"public\".\"content_item\"

alter table \"public\".\"content_item\" enable row level security","alter table \"public\".\"country\" drop column \"created_at\"","alter table \"public\".\"country\" drop column \"created_by\"","alter table \"public\".\"country\" drop column \"id\"","alter table \"public\".\"country\" drop column \"updated_at\"","alter table \"public\".\"country\" drop column \"updated_by\"","alter table \"public\".\"country\" add column \"published_at\" timestamp with time zone","alter table \"public\".\"country\" add column \"published_by\" bigint","alter table \"public\".\"country\" add column \"table_name\" text not null default ''country''::text","alter table \"public\".\"country\" add column \"unpublished_at\" timestamp with time zone","alter table \"public\".\"country\" add column \"unpublished_by\" bigint","alter table \"public\".\"country\" add constraint \"country_table_name_check\" CHECK ((table_name = ''country''::text)) not valid","alter table \"public\".\"country\" validate constraint \"country_table_name_check\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.fn_any_type(r record)
 RETURNS record
 LANGUAGE plpgsql
AS $function$
DECLARE
	t record;
BEGIN
  t := r;
  t.updated_at := NOW();
	RETURN t;
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_content_item_edit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN record_fill_updated_by(record_fill_updated_at(NEW));
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_content_item_new()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN record_fill_created_by(NEW);
END;
$function$","CREATE OR REPLACE FUNCTION public.record_fill_created_by(r record)
 RETURNS record
 LANGUAGE plpgsql
AS $function$
DECLARE
	t record;
BEGIN
  t := r;
  t.created_by := get_my_claim(''profile_id'');
	RETURN t;
END;
$function$","CREATE OR REPLACE FUNCTION public.record_fill_updated_at(r record)
 RETURNS record
 LANGUAGE plpgsql
AS $function$
DECLARE
	t record;
BEGIN
  t := r;
  t.updated_at := NOW();
	RETURN t;
END;
$function$","CREATE OR REPLACE FUNCTION public.record_fill_updated_by(r record)
 RETURNS record
 LANGUAGE plpgsql
AS $function$
DECLARE
	t record;
BEGIN
  t := r;
  t.updated_by := get_my_claim(''profile_id'');
	RETURN t;
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_content_item_check_delete(record content_item)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
	RETURN rls_check_delete_by_created_by(record.created_by);
END;
$function$","CREATE OR REPLACE FUNCTION public.rls_content_item_check_edit(record content_item)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
	RETURN rls_check_edit_by_created_by(record.created_by);
END;
$function$","create or replace view \"public\".\"view_rls_content_item\" as  SELECT content_item.table_name,
    content_item.id,
    rls_content_item_check_edit(content_item.*) AS editable,
    rls_content_item_check_delete(content_item.*) AS deletable
   FROM content_item
  ORDER BY content_item.table_name, content_item.id","CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length 
      THEN substring(s, 1, max_length - 3) || ''...'' 
      ELSE s
      END;
END;
$function$","create or replace view \"public\".\"view_rls_edit_for_table\" as  SELECT view_rls_content_item.table_name,
    view_rls_content_item.id,
    view_rls_content_item.editable,
    view_rls_content_item.deletable
   FROM view_rls_content_item
UNION
 SELECT ''author''::text AS table_name,
    author.id,
    rls_authors_edit(author.*) AS editable,
    rls_authors_delete(author.*) AS deletable
   FROM author
UNION
 SELECT ''citation''::text AS table_name,
    citation.id,
    rls_citations_edit(citation.*) AS editable,
    rls_citations_delete(citation.*) AS deletable
   FROM citation
UNION
 SELECT ''event''::text AS table_name,
    event.id,
    rls_events_edit(event.*) AS editable,
    rls_events_delete(event.*) AS deletable
   FROM event
UNION
 SELECT ''place''::text AS table_name,
    place.id,
    rls_places_edit(place.*) AS editable,
    rls_places_delete(place.*) AS deletable
   FROM place
UNION
 SELECT ''profile''::text AS table_name,
    profile.id,
    rls_profiles_edit(profile.*) AS editable,
    false AS deletable
   FROM profile
UNION
 SELECT ''town''::text AS table_name,
    town.id,
    rls_towns_edit(town.*) AS editable,
    rls_towns_delete(town.*) AS deletable
   FROM town
UNION
 SELECT ''trust''::text AS table_name,
    trust.id,
    rls_trusts_edit(trust.*) AS editable,
    rls_trusts_edit(trust.*) AS deletable
   FROM trust
  ORDER BY 1, 2","create policy \"RLS: content_item: select\"
on \"public\".\"content_item\"
as permissive
for select
to public
using (true)","create policy \"RLS: country: delete\"
on \"public\".\"country\"
as permissive
for delete
to authenticated
using (rls_content_item_check_delete((country.*)::content_item))","create policy \"RLS: country: insert\"
on \"public\".\"country\"
as permissive
for insert
to authenticated
with check (rls_content_item_check_edit((country.*)::content_item))","create policy \"RLS: country: select\"
on \"public\".\"country\"
as permissive
for select
to public
using (true)","create policy \"RLS: country: update\"
on \"public\".\"country\"
as permissive
for update
to authenticated
using (rls_content_item_check_edit((country.*)::content_item))
with check (rls_content_item_check_edit((country.*)::content_item))","CREATE TRIGGER on_country_edit BEFORE UPDATE ON public.country FOR EACH ROW EXECUTE FUNCTION handle_content_item_edit()","CREATE TRIGGER on_country_new BEFORE UPDATE ON public.country FOR EACH ROW EXECUTE FUNCTION handle_content_item_new()"}', 'new_content_item_triggers_for_country'),
	('20240116024740', '{"drop trigger if exists \"on_country_new\" on \"public\".\"country\"","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.equal_or_both_null(a anycompatible, b anycompatible)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  result BOOLEAN;
BEGIN
  result := (a = b) OR (a IS NULL AND b IS NULL);
  IF result IS NULL THEN
    RETURN FALSE;
  END IF;
  RETURN result;
END;
$function$","CREATE OR REPLACE FUNCTION public.protect_generated_field_from_change(a anyelement, b anyelement, variable_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NOT (equal_or_both_null(a, b)) THEN
    RAISE EXCEPTION ''\"%\" is autogenerated field. Change not allowed'', variable_name;
  END IF;
END;
$function$","CREATE OR REPLACE FUNCTION public.protect_generated_field_from_init(a anyelement, variable_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF a IS NOT NULL THEN
    RAISE EXCEPTION ''\"%\" is autogenerated field. Init is not allowed'', variable_name;
  END IF;
END;
$function$","CREATE OR REPLACE FUNCTION public.content_item_edit_protect_generated_fields(new content_item, old content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

  PERFORM protect_generated_field_from_change(new.id, old.id, ''id'');
  PERFORM protect_generated_field_from_change(new.table_name, old.table_name, ''table_name'');
  PERFORM protect_generated_field_from_change(new.created_at, old.created_at, ''created_at'');
  PERFORM protect_generated_field_from_change(new.created_by, old.created_by, ''created_by'');
  PERFORM protect_generated_field_from_change(new.updated_at, old.updated_at, ''updated_at'');
  PERFORM protect_generated_field_from_change(new.updated_by, old.updated_by, ''updated_by'');
  PERFORM protect_generated_field_from_change(new.published_at, old.published_at, ''published_at'');
  PERFORM protect_generated_field_from_change(new.published_by, old.published_by, ''published_by'');
  PERFORM protect_generated_field_from_change(new.unpublished_at, old.unpublished_at, ''unpublished_at'');
  PERFORM protect_generated_field_from_change(new.unpublished_by, old.unpublished_by, ''unpublished_by'');
END;
$function$","CREATE OR REPLACE FUNCTION public.content_item_new_protect_generated_fields(new content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- PERFORM protect_generated_field_from_init(new.table_name, ''table_name'');
  -- PERFORM protect_generated_field_from_init(new.created_at, ''created_at'');
  PERFORM protect_generated_field_from_init(new.created_by, ''created_by'');
  -- PERFORM protect_generated_field_from_init(new.updated_at, ''updated_at'');
  PERFORM protect_generated_field_from_init(new.updated_by, ''updated_by'');
  PERFORM protect_generated_field_from_init(new.published_at, ''published_at'');
  PERFORM protect_generated_field_from_init(new.published_by, ''published_by'');
  PERFORM protect_generated_field_from_init(new.published_by, ''unpublished_at'');
  PERFORM protect_generated_field_from_init(new.published_by, ''unpublished_by'');
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_content_item_edit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	check_result BOOLEAN;
BEGIN
  -- check_result := content_item_protect_generated_fields(NEW, OLD);

  -- IF NOT check_result THEN
  --   RETURN NULL;
  -- END IF;

  -- IF NEW.published_at <> OLD.published_at THEN
  --   RAISE EXCEPTION ''published_at is autogenerated field. Change not allowed'';
  --   RETURN NULL;
  --   -- RETURN FALSE;
  -- END IF;

  PERFORM content_item_edit_protect_generated_fields(NEW, OLD);

  RETURN record_fill_updated_by(record_fill_updated_at(NEW));
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_content_item_new()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM content_item_new_protect_generated_fields(NEW);

  RETURN record_fill_created_by(NEW);
END;
$function$","CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length
      THEN substring(s, 1, max_length - 3) || ''...''
      ELSE s
      END;
END;
$function$","CREATE TRIGGER on_country_new BEFORE INSERT ON public.country FOR EACH ROW EXECUTE FUNCTION handle_content_item_new()"}', 'country_protect_generated_fields'),
	('20240116200127', '{"set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.content_item_publish(_table_name text, _id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- also is checked in before update trigger in content_item_edit_protect_generated_fields()
  PERFORM permission_publish_check();

  -- SET session_replication_role = replica;

  UPDATE content_item
  SET published_at = NOW(),
      published_by = get_my_claim(''profile_id'')::int,
      unpublished_at = NULL,
      unpublished_by = NULL
  WHERE table_name = _table_name 
    AND id = _id;
  -- FORMAT(''UPDATE %I VALUES ($1,$2)''::text ,v_partition_name) using NEW.id,NEW.datetime;

  -- SET session_replication_role = origin;
END;
$function$","CREATE OR REPLACE FUNCTION public.content_item_unpublish(_table_name text, _id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- also is checked in before update trigger in content_item_edit_protect_generated_fields()
  PERFORM permission_publish_check();

  UPDATE content_item
  SET unpublished_at = NOW(),
      unpublished_by = get_my_claim(''profile_id'')::int
  WHERE table_name = _table_name 
    AND id = _id;
END;
$function$","CREATE OR REPLACE FUNCTION public.permission_publish_check()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NOT permission_publish_get() THEN
    RAISE EXCEPTION ''Publish permission required'';
  END IF;
END;
$function$","CREATE OR REPLACE FUNCTION public.permission_publish_get()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN get_my_claim(''claim_publish'')::varchar::boolean OR is_claims_admin();
END;
$function$","CREATE OR REPLACE FUNCTION public.content_item_edit_protect_generated_fields(new content_item, old content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM protect_generated_field_from_change(new.id, old.id, ''id'');
  PERFORM protect_generated_field_from_change(new.table_name, old.table_name, ''table_name'');
  PERFORM protect_generated_field_from_change(new.created_at, old.created_at, ''created_at'');
  PERFORM protect_generated_field_from_change(new.created_by, old.created_by, ''created_by'');
  PERFORM protect_generated_field_from_change(new.updated_at, old.updated_at, ''updated_at'');
  PERFORM protect_generated_field_from_change(new.updated_by, old.updated_by, ''updated_by'');

  IF NOT permission_publish_get() THEN
    PERFORM protect_generated_field_from_change(new.published_at, old.published_at, ''published_at'');
    PERFORM protect_generated_field_from_change(new.published_by, old.published_by, ''published_by'');  
    PERFORM protect_generated_field_from_change(new.unpublished_at, old.unpublished_at, ''unpublished_at'');  
    PERFORM protect_generated_field_from_change(new.unpublished_by, old.unpublished_by, ''unpublished_by'');  
  END IF;
END;
$function$","CREATE OR REPLACE FUNCTION public.content_item_new_protect_generated_fields(new content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- PERFORM protect_generated_field_from_init(new.table_name, ''table_name'');
  -- PERFORM protect_generated_field_from_init(new.created_at, ''created_at'');
  PERFORM protect_generated_field_from_init(new.created_by, ''created_by'');
  -- PERFORM protect_generated_field_from_init(new.updated_at, ''updated_at'');
  PERFORM protect_generated_field_from_init(new.updated_by, ''updated_by'');
  PERFORM protect_generated_field_from_init(new.published_at, ''published_at'');
  PERFORM protect_generated_field_from_init(new.published_by, ''published_by'');  
  PERFORM protect_generated_field_from_init(new.published_by, ''unpublished_at'');  
  PERFORM protect_generated_field_from_init(new.published_by, ''unpublished_by'');  
END;
$function$","CREATE OR REPLACE FUNCTION public.equal_or_both_null(a anycompatible, b anycompatible)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  result BOOLEAN;
BEGIN
  result := (a = b) OR (a IS NULL AND b IS NULL);
  IF result IS NULL THEN 
    RETURN FALSE;
  END IF;
  RETURN result;
END;
$function$","CREATE OR REPLACE FUNCTION public.handle_content_item_edit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	check_result BOOLEAN;  
BEGIN
  -- check_result := content_item_protect_generated_fields(NEW, OLD);

  -- IF NOT check_result THEN
  --   RETURN NULL;
  -- END IF;

  -- IF NEW.published_at <> OLD.published_at THEN
  --   RAISE EXCEPTION ''published_at is autogenerated field. Change not allowed'';
  --   RETURN NULL;
  --   -- RETURN FALSE;
  -- END IF;

  PERFORM content_item_edit_protect_generated_fields(NEW, OLD);

  RETURN record_fill_updated_by(record_fill_updated_at(NEW));
END;
$function$","CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length 
      THEN substring(s, 1, max_length - 3) || ''...'' 
      ELSE s
      END;
END;
$function$"}', 'publish_fns_country'),
	('20240117005735', '{"drop view if exists \"public\".\"view_id_name\"","alter table \"public\".\"content_item\" add column \"published\" boolean generated always as (((published_at IS NOT NULL) AND (unpublished_at IS NULL))) stored","alter table \"public\".\"country\" add column \"published\" boolean generated always as (((published_at IS NOT NULL) AND (unpublished_at IS NULL))) stored","set check_function_bodies = off","CREATE OR REPLACE FUNCTION public.content_item_publish(_table_name text, _id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
-- DECLARE
--   exception_text TEXT;
BEGIN
  -- also is checked in before update trigger in content_item_edit_protect_generated_fields()
  -- exception_text := permission_publish_check();
  PERFORM permission_publish_check();

  -- IF exception_text IS NOT NULL THEN
  --   RETURN exception_text;
  -- END IF;

  -- SET session_replication_role = replica;

  UPDATE content_item
  SET published_at = NOW(),
      published_by = get_my_claim(''profile_id'')::int,
      unpublished_at = NULL,
      unpublished_by = NULL
  WHERE table_name = _table_name
    AND id = _id;
  -- FORMAT(''UPDATE %I VALUES ($1,$2)''::text ,v_partition_name) using NEW.id,NEW.datetime;

  -- RETURN NULL;
  -- SET session_replication_role = origin;
END;
$function$","CREATE OR REPLACE FUNCTION public.permission_publish_check()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
-- DECLARE
--   exception_text TEXT;
BEGIN
  IF NOT permission_publish_get() THEN
    -- exception_text := ''Publish permission required'';
    RAISE EXCEPTION ''Publish permission required'';
    -- RETURN exception_text;
  END IF;
  -- RETURN NULL;
END;
$function$","CREATE OR REPLACE FUNCTION public.permission_publish_get()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN COALESCE(get_my_claim(''claim_publish'')::varchar::boolean, FALSE) OR is_claims_admin();
END;
$function$","-- create or replace view \"public\".\"view_id_name\" as  SELECT ''author''::text AS table_name,
--     author.id,
--     author.lastname_name_patronymic AS name,
--     string_limit((author.lastname_name_patronymic)::character varying, 20) AS short_name
--    FROM author
-- UNION
--  SELECT ''citation''::text AS table_name,
--     citation.id,
--     string_limit((citation.english_text)::character varying, 40) AS name,
--     string_limit((citation.english_text)::character varying, 20) AS short_name
--    FROM citation
-- UNION
--  SELECT ''country''::text AS table_name,
--     country.id,
--     country.name,
--     string_limit((country.name)::character varying, 20) AS short_name
--    FROM country
-- UNION
--  SELECT ''place''::text AS table_name,
--     place.id,
--     place.name,
--     string_limit((place.name)::character varying, 20) AS short_name
--    FROM place
-- UNION
--  SELECT ''profile''::text AS table_name,
--     profile.id,
--     (((profile.full_name || '' (''::text) || profile.username) || '')''::text) AS name,
--     profile.username AS short_name
--    FROM profile
-- UNION
--  SELECT ''town''::text AS table_name,
--     town.id,
--     town.name,
--     string_limit((town.name)::character varying, 20) AS short_name
--    FROM town
--   ORDER BY 1, 4;"}', 'publish_country_fix'),
	('20240117192135', '{"drop policy \"RLS: country: select\" on \"public\".\"country\"","alter table \"public\".\"country\" drop constraint \"countries_name_check\"","alter table \"public\".\"country\" drop constraint \"countries_name_key\"","alter table \"public\".\"town\" drop constraint \"towns_name_check\"","drop view if exists \"public\".\"view_rls_edit_for_table\"","drop index if exists \"public\".\"countries_name_key\"","alter table \"public\".\"author\" drop column \"lastname_name_patronymic\"","alter table \"public\".\"author\" add column \"name_en\" text not null","alter table \"public\".\"citation\" drop column \"english_text\"","alter table \"public\".\"citation\" add column \"text_en\" text","alter table \"public\".\"event\" drop column \"name\"","alter table \"public\".\"event\" add column \"name_en\" text not null","alter table \"public\".\"place\" drop column \"name\"","alter table \"public\".\"place\" add column \"name_en\" text not null default ''in''::text","alter table \"public\".\"town\" drop column \"name\"","alter table \"public\".\"town\" add column \"name_en\" text not null","alter table \"public\".\"country\" drop column \"name\"","alter table \"public\".\"country\" add column \"name_en\" text not null default ''''::text","CREATE UNIQUE INDEX countries_name_key ON public.country USING btree (name_en)","alter table \"public\".\"country\" add constraint \"countries_name_check\" CHECK ((length(name_en) > 0)) not valid","alter table \"public\".\"country\" validate constraint \"countries_name_check\"","alter table \"public\".\"country\" add constraint \"countries_name_key\" UNIQUE using index \"countries_name_key\"","alter table \"public\".\"town\" add constraint \"towns_name_check\" CHECK ((length(name_en) > 0)) not valid","alter table \"public\".\"town\" validate constraint \"towns_name_check\"","set check_function_bodies = off","create or replace view \"public\".\"view_id_name\" as  SELECT ''author''::text AS table_name,
    author.id,
    author.name_en AS name,
    string_limit((author.name_en)::character varying, 20) AS short_name
   FROM author
UNION
 SELECT ''citation''::text AS table_name,
    citation.id,
    string_limit((citation.text_en)::character varying, 40) AS name,
    string_limit((citation.text_en)::character varying, 20) AS short_name
   FROM citation
UNION
 SELECT ''country''::text AS table_name,
    country.id,
    country.name_en AS name,
    string_limit((country.name_en)::character varying, 20) AS short_name
   FROM country
UNION
 SELECT ''place''::text AS table_name,
    place.id,
    place.name_en AS name,
    string_limit((place.name_en)::character varying, 20) AS short_name
   FROM place
UNION
 SELECT ''profile''::text AS table_name,
    profile.id,
    (((profile.full_name || '' (''::text) || profile.username) || '')''::text) AS name,
    profile.username AS short_name
   FROM profile
UNION
 SELECT ''town''::text AS table_name,
    town.id,
    town.name_en AS name,
    string_limit((town.name_en)::character varying, 20) AS short_name
   FROM town
  ORDER BY 1, 4","CREATE OR REPLACE FUNCTION public.content_item_publish(_table_name text, _id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
-- DECLARE
--   exception_text TEXT;
BEGIN
  -- also is checked in before update trigger in content_item_edit_protect_generated_fields()
  -- exception_text := permission_publish_check();
  PERFORM permission_publish_check();

  -- IF exception_text IS NOT NULL THEN
  --   RETURN exception_text;
  -- END IF;

  -- SET session_replication_role = replica;

  UPDATE content_item
  SET published_at = NOW(),
      published_by = get_my_claim(''profile_id'')::int,
      unpublished_at = NULL,
      unpublished_by = NULL
  WHERE table_name = _table_name 
    AND id = _id;
  -- FORMAT(''UPDATE %I VALUES ($1,$2)''::text ,v_partition_name) using NEW.id,NEW.datetime;

  -- RETURN NULL;
  -- SET session_replication_role = origin;
END;
$function$","create or replace view \"public\".\"view_rls_edit_for_table\" as  SELECT view_rls_content_item.table_name,
    view_rls_content_item.id,
    view_rls_content_item.editable,
    view_rls_content_item.deletable
   FROM view_rls_content_item
UNION
 SELECT ''author''::text AS table_name,
    author.id,
    rls_authors_edit(author.*) AS editable,
    rls_authors_delete(author.*) AS deletable
   FROM author
UNION
 SELECT ''citation''::text AS table_name,
    citation.id,
    rls_citations_edit(citation.*) AS editable,
    rls_citations_delete(citation.*) AS deletable
   FROM citation
UNION
 SELECT ''event''::text AS table_name,
    event.id,
    rls_events_edit(event.*) AS editable,
    rls_events_delete(event.*) AS deletable
   FROM event
UNION
 SELECT ''place''::text AS table_name,
    place.id,
    rls_places_edit(place.*) AS editable,
    rls_places_delete(place.*) AS deletable
   FROM place
UNION
 SELECT ''profile''::text AS table_name,
    profile.id,
    rls_profiles_edit(profile.*) AS editable,
    false AS deletable
   FROM profile
UNION
 SELECT ''town''::text AS table_name,
    town.id,
    rls_towns_edit(town.*) AS editable,
    rls_towns_delete(town.*) AS deletable
   FROM town
UNION
 SELECT ''trust''::text AS table_name,
    trust.id,
    rls_trusts_edit(trust.*) AS editable,
    rls_trusts_edit(trust.*) AS deletable
   FROM trust
  ORDER BY 1, 2","create policy \"RLS: country: select (guest)\"
on \"public\".\"country\"
as permissive
for select
to anon
using (published)","create policy \"RLS: country: select\"
on \"public\".\"country\"
as permissive
for select
to authenticated
using (true)"}', 'data_loss_name_en_col_unify');


--
-- PostgreSQL database dump complete
--

RESET ALL;
