drop trigger if exists "on_country_new" on "public"."country";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.equal_or_both_null(a anycompatible, b anycompatible)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  result BOOLEAN;
BEGIN
  result := (a = b) OR (a IS NULL AND b IS NULL);
  IF result IS NULL THEN
    RETURN FALSE;
  END IF;
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.protect_generated_field_from_change(a anyelement, b anyelement, variable_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NOT (equal_or_both_null(a, b)) THEN
    RAISE EXCEPTION '"%" is autogenerated field. Change not allowed', variable_name;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.protect_generated_field_from_init(a anyelement, variable_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF a IS NOT NULL THEN
    RAISE EXCEPTION '"%" is autogenerated field. Init is not allowed', variable_name;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.content_item_edit_protect_generated_fields(new content_item, old content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

  PERFORM protect_generated_field_from_change(new.id, old.id, 'id');
  PERFORM protect_generated_field_from_change(new.table_name, old.table_name, 'table_name');
  PERFORM protect_generated_field_from_change(new.created_at, old.created_at, 'created_at');
  PERFORM protect_generated_field_from_change(new.created_by, old.created_by, 'created_by');
  PERFORM protect_generated_field_from_change(new.updated_at, old.updated_at, 'updated_at');
  PERFORM protect_generated_field_from_change(new.updated_by, old.updated_by, 'updated_by');
  PERFORM protect_generated_field_from_change(new.published_at, old.published_at, 'published_at');
  PERFORM protect_generated_field_from_change(new.published_by, old.published_by, 'published_by');
  PERFORM protect_generated_field_from_change(new.unpublished_at, old.unpublished_at, 'unpublished_at');
  PERFORM protect_generated_field_from_change(new.unpublished_by, old.unpublished_by, 'unpublished_by');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.content_item_new_protect_generated_fields(new content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- PERFORM protect_generated_field_from_init(new.table_name, 'table_name');
  -- PERFORM protect_generated_field_from_init(new.created_at, 'created_at');
  PERFORM protect_generated_field_from_init(new.created_by, 'created_by');
  -- PERFORM protect_generated_field_from_init(new.updated_at, 'updated_at');
  PERFORM protect_generated_field_from_init(new.updated_by, 'updated_by');
  PERFORM protect_generated_field_from_init(new.published_at, 'published_at');
  PERFORM protect_generated_field_from_init(new.published_by, 'published_by');
  PERFORM protect_generated_field_from_init(new.published_by, 'unpublished_at');
  PERFORM protect_generated_field_from_init(new.published_by, 'unpublished_by');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_content_item_edit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	check_result BOOLEAN;
BEGIN
  -- check_result := content_item_protect_generated_fields(NEW, OLD);

  -- IF NOT check_result THEN
  --   RETURN NULL;
  -- END IF;

  -- IF NEW.published_at <> OLD.published_at THEN
  --   RAISE EXCEPTION 'published_at is autogenerated field. Change not allowed';
  --   RETURN NULL;
  --   -- RETURN FALSE;
  -- END IF;

  PERFORM content_item_edit_protect_generated_fields(NEW, OLD);

  RETURN record_fill_updated_by(record_fill_updated_at(NEW));
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_content_item_new()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM content_item_new_protect_generated_fields(NEW);

  RETURN record_fill_created_by(NEW);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length
      THEN substring(s, 1, max_length - 3) || '...'
      ELSE s
      END;
END;
$function$
;

CREATE TRIGGER on_country_new BEFORE INSERT ON public.country FOR EACH ROW EXECUTE FUNCTION handle_content_item_new();


