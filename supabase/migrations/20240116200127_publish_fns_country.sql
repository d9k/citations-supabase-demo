set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.content_item_publish(_table_name text, _id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- also is checked in before update trigger in content_item_edit_protect_generated_fields()
  PERFORM permission_publish_check();

  -- SET session_replication_role = replica;

  UPDATE content_item
  SET published_at = NOW(),
      published_by = get_my_claim('profile_id')::int,
      unpublished_at = NULL,
      unpublished_by = NULL
  WHERE table_name = _table_name 
    AND id = _id;
  -- FORMAT('UPDATE %I VALUES ($1,$2)'::text ,v_partition_name) using NEW.id,NEW.datetime;

  -- SET session_replication_role = origin;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.content_item_unpublish(_table_name text, _id integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- also is checked in before update trigger in content_item_edit_protect_generated_fields()
  PERFORM permission_publish_check();

  UPDATE content_item
  SET unpublished_at = NOW(),
      unpublished_by = get_my_claim('profile_id')::int
  WHERE table_name = _table_name 
    AND id = _id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.permission_publish_check()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NOT permission_publish_get() THEN
    RAISE EXCEPTION 'Publish permission required';
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.permission_publish_get()
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN get_my_claim('claim_publish')::varchar::boolean OR is_claims_admin();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.content_item_edit_protect_generated_fields(new content_item, old content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM protect_generated_field_from_change(new.id, old.id, 'id');
  PERFORM protect_generated_field_from_change(new.table_name, old.table_name, 'table_name');
  PERFORM protect_generated_field_from_change(new.created_at, old.created_at, 'created_at');
  PERFORM protect_generated_field_from_change(new.created_by, old.created_by, 'created_by');
  PERFORM protect_generated_field_from_change(new.updated_at, old.updated_at, 'updated_at');
  PERFORM protect_generated_field_from_change(new.updated_by, old.updated_by, 'updated_by');

  IF NOT permission_publish_get() THEN
    PERFORM protect_generated_field_from_change(new.published_at, old.published_at, 'published_at');
    PERFORM protect_generated_field_from_change(new.published_by, old.published_by, 'published_by');  
    PERFORM protect_generated_field_from_change(new.unpublished_at, old.unpublished_at, 'unpublished_at');  
    PERFORM protect_generated_field_from_change(new.unpublished_by, old.unpublished_by, 'unpublished_by');  
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.content_item_new_protect_generated_fields(new content_item)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- PERFORM protect_generated_field_from_init(new.table_name, 'table_name');
  -- PERFORM protect_generated_field_from_init(new.created_at, 'created_at');
  PERFORM protect_generated_field_from_init(new.created_by, 'created_by');
  -- PERFORM protect_generated_field_from_init(new.updated_at, 'updated_at');
  PERFORM protect_generated_field_from_init(new.updated_by, 'updated_by');
  PERFORM protect_generated_field_from_init(new.published_at, 'published_at');
  PERFORM protect_generated_field_from_init(new.published_by, 'published_by');  
  PERFORM protect_generated_field_from_init(new.published_by, 'unpublished_at');  
  PERFORM protect_generated_field_from_init(new.published_by, 'unpublished_by');  
END;
$function$
;

CREATE OR REPLACE FUNCTION public.equal_or_both_null(a anycompatible, b anycompatible)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  result BOOLEAN;
BEGIN
  result := (a = b) OR (a IS NULL AND b IS NULL);
  IF result IS NULL THEN 
    RETURN FALSE;
  END IF;
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_content_item_edit()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
	check_result BOOLEAN;  
BEGIN
  -- check_result := content_item_protect_generated_fields(NEW, OLD);

  -- IF NOT check_result THEN
  --   RETURN NULL;
  -- END IF;

  -- IF NEW.published_at <> OLD.published_at THEN
  --   RAISE EXCEPTION 'published_at is autogenerated field. Change not allowed';
  --   RETURN NULL;
  --   -- RETURN FALSE;
  -- END IF;

  PERFORM content_item_edit_protect_generated_fields(NEW, OLD);

  RETURN record_fill_updated_by(record_fill_updated_at(NEW));
END;
$function$
;

CREATE OR REPLACE FUNCTION public.string_limit(s character varying, max_length integer)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN CASE WHEN length(s) > max_length 
      THEN substring(s, 1, max_length - 3) || '...' 
      ELSE s
      END;
END;
$function$
;


