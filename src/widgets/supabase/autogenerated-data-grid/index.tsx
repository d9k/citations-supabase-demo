import { JsonView } from '/~/shared/ui/json-view.tsx';
import { WithQueryKeyUniqueSuffix } from '/~/shared/lib/react/query/key.ts';
import { useQuery } from '@tanstack/react-query';
import { useSupabase } from '/~/shared/providers/supabase/client.ts';
import {
  DbFieldInfo,
  DbTable,
} from '/~/shared/api/supabase/json-schema.types.ts';
import { DataGrid } from '/~/shared/ui/data-grid/index.tsx';
import { useMemo } from 'react';
import { Column } from '/~/shared/ui/data-grid/index.tsx';

import { Tables } from '/~/shared/api/supabase/types.generated.ts';

type RlsEditForTable = Tables<'rls_edit_for_table'>;

//@deno-types="@types/lodash"
import {
  capitalize,
  difference,
  get,
  intersection,
  keys,
  map,
  pick,
} from 'lodash';

// @deno-types="@types/react-data-grid"
import { Row, textEditor } from 'react-data-grid';

import { RecordAny } from '/~/shared/lib/ts/record-any.ts';
import { arrayDiff } from '/~/shared/lib/diff.ts';

import {
  COLUMN_NAME_DELETABLE,
  COLUMN_NAME_EDITABLE,
  FIELDS_AUTOGENERATED,
  FIELDS_IDS,
} from '/~/shared/api/supabase/const.ts';

import { notifications } from '@mantine/notifications';
import { json } from '/~/shared/lib/json.ts';
import { useState } from 'react';

import { useFieldsNames } from './hooks.tsx';

export type SupabaseAutogeneratedDataGridProps = {
  allowInsert?: boolean;
  columnsNamesFirst?: string[];
  columnsNamesLast?: string[];
  onReloadRequired?: () => void;
  tableName: string;
  tableSchema: DbTable;
} & WithQueryKeyUniqueSuffix;

type RlsInfoById = { [id: number]: RlsEditForTable };

type R = RecordAny;
export type ColumnAny = Column<RecordAny>;

const NEW_RECORD_ID = '+';

const ERROR_SUPABASE_SHOW_DELAY = 8000;

const ELEMENT_NAME = 'SupabaseAutogeneratedDataGrid';

export const SupabaseAutogeneratedDataGrid = (
  {
    allowInsert = true,
    columnsNamesFirst = ['id', COLUMN_NAME_EDITABLE],
    columnsNamesLast = [],
    onReloadRequired,
    tableName,
    tableSchema,
    queryKeyUniqueSuffix,
  }: SupabaseAutogeneratedDataGridProps,
) => {
  const rowKeyGetter = (row: RecordAny | null) => row?.id;

  // deno-lint-ignore no-explicit-any
  const rowKeySetter = (row: RecordAny, values: any[]) => row.id = values[0];

  const createDummyRecord = (fieldsNamesEditable: string[]) => {
    const result = {
      /** To prevent warn "A component is changing an uncontrolled input to be controlled" */
      ...Object.fromEntries(fieldsNamesEditable.map((n) => [n, ''])),
    };

    rowKeySetter(result, [NEW_RECORD_ID]);

    return result;
  };

  console.debug(
    `${ELEMENT_NAME}: queryKeyUniqueSuffix:`,
    queryKeyUniqueSuffix,
  );
  const supabase = useSupabase();

  const { data: tableDataResult, isFetched, error } = useQuery({
    queryKey: [ELEMENT_NAME + '_' + queryKeyUniqueSuffix],
    queryFn: () => supabase?.from(tableName).select('*'),
  });

  // TODO Supabase type
  const tableData = ((tableDataResult || {}) as RecordAny).data;

  const ids = map(tableData, 'id') || [];

  const { data: editableDataResult } = useQuery({
    queryKey: [ELEMENT_NAME + '_editable_' + queryKeyUniqueSuffix],
    enabled: ids.length > 0,
    queryFn: () =>
      supabase?.from('rls_edit_for_table').select().eq('table_name', tableName)
        .in('id', ids),
  });

  // TODO type
  const rlsInfoArray: RlsEditForTable[] = (editableDataResult as any)?.data ||
    [];

  const hasRlsInfo = rlsInfoArray.length > 0;

  const rlsInfoById: RlsInfoById = useMemo(() =>
    Object.fromEntries(
      rlsInfoArray.map((rlsInfo) => [rlsInfo.id, rlsInfo]),
    ), [rlsInfoArray]);

  const [currentRow, setCurrentRow] = useState<RecordAny | null>(null);

  const {
    fieldsNamesEditable,
    fieldsNamesNullable,
    fieldsNames,
    fieldsNamesRequired,
  } = useFieldsNames({ hasRlsInfo, tableSchema });

  const rows = useMemo(() => {
    let result = [...(tableData || [])];

    if (hasRlsInfo) {
      result = result.map((r) => ({
        ...r,
        [COLUMN_NAME_EDITABLE]: rlsInfoById[r.id].editable ? 'yes' : '',
        [COLUMN_NAME_DELETABLE]: rlsInfoById[r.id].editable ? 'yes' : '',
      }));
    }

    if (allowInsert) {
      result = [createDummyRecord(fieldsNamesEditable), ...result];
    }

    const currentRowId = rowKeyGetter(currentRow);

    return result.map((r) =>
      (rowKeyGetter(r) === currentRowId) ? currentRow : r
    );
  }, [currentRow, rlsInfoById, hasRlsInfo, tableData]);

  const columns: ColumnAny[] = useMemo(() => {
    const fieldsNamesFirst = intersection(
      columnsNamesFirst,
      fieldsNames,
    );
    const fieldsNamesLast = intersection(columnsNamesLast, fieldsNames);
    const fieldsNamesRest = difference(
      fieldsNames,
      columnsNamesFirst,
      columnsNamesLast,
    );

    const fieldsNamesRestSorted = [
      ...intersection(fieldsNamesRest, fieldsNamesRequired).sort(),
      ...difference(fieldsNamesRest, fieldsNamesRequired).sort(),
    ];

    const fieldsNamesSorted = [
      ...fieldsNamesFirst,
      ...fieldsNamesRestSorted,
      ...fieldsNamesLast,
    ];

    return fieldsNamesSorted.map((fieldName) => {
      const required = fieldsNamesRequired.includes(fieldName);

      const column: ColumnAny = {
        editable: !FIELDS_AUTOGENERATED.includes(fieldName),
        frozen: FIELDS_IDS.includes(fieldName),
        key: fieldName,
        name: `${fieldName}${required ? ' *' : ''}`,
        renderEditCell: textEditor,
      };

      return column;
    });
  }, [tableSchema, hasRlsInfo]);

  console.log(`${ELEMENT_NAME}: columns:`, columns);

  const handleRowsChange = async (newRows: RecordAny[]) => {
    const changedRows = arrayDiff(newRows, rows);

    const changedRowAllFields = changedRows[0];

    setCurrentRow(changedRowAllFields);

    const id = rowKeyGetter(changedRowAllFields);

    console.log(
      `${ELEMENT_NAME}: handleRowsChange:`,
      changedRowAllFields,
    );

    const fieldsNames = keys(changedRowAllFields);
    const filteredFieldsNames = intersection(fieldsNames, fieldsNamesEditable);
    const changedRow = pick(
      changedRowAllFields,
      filteredFieldsNames,
    );

    if (!id) {
      throw Error('id not set');
    }

    const insertMode = id === NEW_RECORD_ID;
    const insertModeText = insertMode ? 'insert' : 'update';
    const insertModeTextCapital = capitalize(insertModeText);

    let errorText = '';
    let result = null;

    fieldsNamesNullable.forEach((n) => {
      if (changedRow[n] === '') {
        changedRow[n] = null;
      }
    });

    try {
      if (insertMode) {
        result = await supabase?.from(tableName).insert(changedRow);
      } else {
        result = await supabase?.from(tableName).update(changedRow).eq(
          'id',
          id,
        );
      }

      console.log(
        `${ELEMENT_NAME}: ${insertModeText} result:`,
        result,
        'changed row:',
        changedRow,
      );
    } catch (e) {
      errorText = json(e);
    }

    errorText ||= result?.error ? json(result.error) : '';

    if (errorText) {
      notifications.show({
        color: 'red',
        title: `Error while row ${insertModeText}`,
        message: errorText,
        autoClose: ERROR_SUPABASE_SHOW_DELAY,
      });
      console.error(errorText);
    } else {
      notifications.show({
        message: `${insertModeTextCapital} successfull`,
      });

      onReloadRequired?.();
      setCurrentRow(null);
    }
  };

  return (
    <>
      {isFetched
        ? (
          <>
            <DataGrid
              columns={columns}
              rows={rows}
              onRowsChange={handleRowsChange}
            />
            <JsonView
              data={{ tableDataResult, editableDataResult, rows, tableSchema }}
            />
          </>
        )
        : undefined}
    </>
  );
};
