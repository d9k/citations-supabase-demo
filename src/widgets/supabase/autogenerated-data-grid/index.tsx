import { JsonView } from '/~/shared/ui/json-view.tsx';
import { WithQueryKeyUniqueSuffix } from '/~/shared/lib/react/query/key.ts';
import { useQuery } from '@tanstack/react-query';
import { useSupabase } from '/~/shared/providers/supabase/index.ts';
import { DbTable } from '/~/shared/api/supabase/json-schema.types.ts';
import { DataGrid } from '/~/shared/ui/data-grid/index.tsx';
import { useMemo } from 'react';

import { useForeignTables } from '/~/shared/api/supabase/hooks/foreign-tables.ts';

import { useColumns } from './hooks/columns.tsx';

//@deno-types="@types/lodash"
import { capitalize, intersection, keys, map, pick } from 'lodash';

import { RecordAny } from '/~/shared/lib/ts/record-any.ts';
import { arrayDiff } from '/~/shared/lib/diff.ts';

import {
  COLUMN_NAME_DELETABLE,
  COLUMN_NAME_EDITABLE,
  COLUMNS_AUTOGENERATED,
  COLUMNS_IDS,
} from '/~/shared/api/supabase/const.ts';

import {
  DEFAULT_KEY_GETTER,
  DEFAULT_KEY_SETTER,
} from '/~/shared/api/supabase/helpers/key.ts';

import { notifications } from '@mantine/notifications';
import { json } from '/~/shared/lib/json.ts';
import { useState } from 'react';

import { useColumnsNames } from '/~/shared/api/supabase/hooks/columns-names.ts';
import { Stack } from '@mantine/core';

export type SupabaseAutogeneratedDataGridProps = {
  allowInsert?: boolean;
  columnsNamesFirst?: string[];
  columnsNamesLast?: string[];
  onReloadRequired?: () => void;
  tableName: string;
  tableSchema: DbTable;
} & WithQueryKeyUniqueSuffix;

import { ERROR_SUPABASE_SHOW_DELAY, NEW_RECORD_ID } from './const.ts';

import { useCreateDummyRecord } from './hooks/create-dummy-record.ts';

import { useSupabaseQueryRlsInfo } from '/~/shared/api/supabase/hooks/query-rls-info.ts';
import { useSupabaseQueryTableData } from '/~/shared/api/supabase/hooks/query-table-data.ts';
import { useSupabaseQueryIdName } from '/~/shared/api/supabase/hooks/query-id-name.ts';
import { useDisclosure } from '@mantine/hooks';
import { useCallback } from 'react';

import { ModalDeleteRow } from './modal-delete-row.tsx';

export const ELEMENT_NAME = 'SupabaseAutogeneratedDataGrid';

export const SupabaseAutogeneratedDataGrid = (
  {
    allowInsert = true,
    columnsNamesFirst = ['id', COLUMN_NAME_EDITABLE],
    columnsNamesLast = [],
    onReloadRequired,
    tableName,
    tableSchema,
    queryKeyUniqueSuffix,
  }: SupabaseAutogeneratedDataGridProps,
) => {
  const rowKeyGetter = DEFAULT_KEY_GETTER;
  const rowKeySetter = DEFAULT_KEY_SETTER;

  const [
    modalDeleteItemOpened,
    { open: modalDeleteItemOpen, close: modalDeleteItemClose },
  ] = useDisclosure();

  const { createDummyRecord } = useCreateDummyRecord({ rowKeySetter });

  // console.debug(
  //   `${ELEMENT_NAME}: queryKeyUniqueSuffix:`,
  //   queryKeyUniqueSuffix,
  // );
  const supabase = useSupabase();

  const { isFetchedTableData, resultTableData, tableData, tableDataIds } =
    useSupabaseQueryTableData({
      tableName,
      queryKeyUniqueSuffix,
    });

  /** current row which is edited */
  const [currentRow, setCurrentRow] = useState<RecordAny | null>(null);
  const [rowToDelete, setRowToDelete] = useState<RecordAny | null>(null);

  const {
    hasRlsInfo,
    rlsInfoById,
    resultRlsInfo,
  } = useSupabaseQueryRlsInfo({
    queryKeyUniqueSuffix,
    tableDataIds,
    tableName,
  });

  const {
    columnsNamesEditable,
    columnsNamesNullable,
    columnsNames,
    columnsNamesRequired,
  } = useColumnsNames({ hasRlsInfo, tableSchema });

  const rows = useMemo(() => {
    let result = [...(tableData || [])];

    if (hasRlsInfo) {
      result = result.map((r) => ({
        ...r,
        [COLUMN_NAME_EDITABLE]: rlsInfoById[r.id]?.editable ? 'yes' : '',
        [COLUMN_NAME_DELETABLE]: rlsInfoById[r.id]?.deletable ? 'yes' : '',
      }));
    }

    if (allowInsert) {
      result = [createDummyRecord(columnsNamesEditable), ...result];
    }

    const currentRowId = rowKeyGetter(currentRow);

    return result.map((r) =>
      (rowKeyGetter(r) === currentRowId) ? currentRow : r
    );
  }, [currentRow, rlsInfoById, hasRlsInfo, tableData]);

  const { foreignTablesNames, fieldToForeignTable } = useForeignTables(
    tableSchema,
  );

  const { foreignidsNames } = useSupabaseQueryIdName({
    foreignTablesNames,
    queryKeyUniqueSuffix,
  });

  const onRowDelete = useCallback(async (rowToDelete: RecordAny) => {
    const id = rowKeyGetter(rowToDelete);

    if (!id) {
      throw Error('id not set');
    }

    let errorText = '';
    let result = null;

    try {
      result = await supabase?.from(tableName).delete().eq('id', id);

      console.log(
        `${ELEMENT_NAME}: delete result:`,
        result,
        'deleting row:',
        rowToDelete,
      );
    } catch (e) {
      errorText = json(e);
    }

    errorText ||= result?.error ? json(result.error) : '';

    if (errorText) {
      notifications.show({
        color: 'red',
        title: `Error while row deletion`,
        message: <pre style={{ whiteSpace: 'pre-wrap' }}>{errorText}</pre>,
        autoClose: ERROR_SUPABASE_SHOW_DELAY,
      });
      console.error(errorText);
      return false;
    } else {
      notifications.show({
        message: `Error deletion successfull`,
      });

      setRowToDelete(null);
      onReloadRequired?.();
      return true;
    }
  }, []);

  const onRowActionDelete = useCallback((row: RecordAny) => {
    console.log(`${ELEMENT_NAME}: TODO handleRowDelete:`, row);
    setRowToDelete(row);
    modalDeleteItemOpen();
  }, [modalDeleteItemOpen, setRowToDelete]);

  const { columns, foreignTableToSelectorItems } = useColumns({
    columnsNamesAutogenerated: COLUMNS_AUTOGENERATED,
    columnsNamesIds: COLUMNS_IDS,
    columnsNamesFirst,
    columnsNamesLast,
    columnsNames,
    columnsNamesRequired,
    foreignidsNames,
    fieldToForeignTable,
    onRowActionDelete,
  });

  console.log(`${ELEMENT_NAME}: columns:`, columns);

  const handleRowsChange = async (newRows: RecordAny[]) => {
    const changedRows = arrayDiff(newRows, rows);

    const changedRowAllFields = changedRows[0];

    setCurrentRow(changedRowAllFields);

    const id = rowKeyGetter(changedRowAllFields);

    console.log(
      `${ELEMENT_NAME}: handleRowsChange:`,
      changedRowAllFields,
    );

    const fieldsNames = keys(changedRowAllFields);
    const filteredFieldsNames = intersection(fieldsNames, columnsNamesEditable);
    const changedRow = pick(
      changedRowAllFields,
      filteredFieldsNames,
    );

    if (!id) {
      throw Error('id not set');
    }

    const insertMode = id === NEW_RECORD_ID;
    const insertModeText = insertMode ? 'insert' : 'update';
    const insertModeTextCapital = capitalize(insertModeText);

    let errorText = '';
    let result = null;

    columnsNamesNullable.forEach((n) => {
      if (changedRow[n] === '') {
        changedRow[n] = null;
      }
    });

    try {
      if (insertMode) {
        result = await supabase?.from(tableName).insert(changedRow);
      } else {
        result = await supabase?.from(tableName).update(changedRow).eq(
          'id',
          id,
        );
      }

      console.log(
        `${ELEMENT_NAME}: ${insertModeText} result:`,
        result,
        'changed row:',
        changedRow,
      );
    } catch (e) {
      errorText = json(e);
    }

    errorText ||= result?.error ? json(result.error) : '';

    if (errorText) {
      notifications.show({
        color: 'red',
        title: `Error while row ${insertModeText}`,
        message: <pre style={{ whiteSpace: 'pre-wrap' }}>{errorText}</pre>,
        autoClose: ERROR_SUPABASE_SHOW_DELAY,
      });
      console.error(errorText);
    } else {
      notifications.show({
        message: `${insertModeTextCapital} successfull`,
      });

      onReloadRequired?.();
      setCurrentRow(null);
    }
  };

  return (
    <>
      {isFetchedTableData
        ? (
          <Stack>
            <ModalDeleteRow
              opened={modalDeleteItemOpened}
              onClose={modalDeleteItemClose}
              rowKeyGetter={rowKeyGetter}
              rowToDelete={rowToDelete}
              onRowDelete={onRowDelete}
            />
            <DataGrid
              columns={columns}
              rows={rows}
              onRowsChange={handleRowsChange}
            />
            <div>
              Double click on cell to edit. Edit cells of row with "+" id to add
              a new row.
            </div>
            <div>
              Cell edit{' '}
              <a
                href='https://github.com/adazzle/react-data-grid/issues/3408'
                target='_blank'
              >
                is not available on mobile phone
              </a>{' '}
              for the moment.
            </div>
            <JsonView
              data={{
                resultTableData,
                resultRlsInfo,
                rows,
                tableSchema,
                foreignidsNames,
                foreignTableToSelectorItems,
              }}
            />
          </Stack>
        )
        : undefined}
    </>
  );
};
